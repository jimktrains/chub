// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class AsymmetriclyEncryptedMessage;
class DistinguishedName;
class Image;
class KeyId;
class MessageReference;
class Post;
class PrivateKey;
class PublicKey;
class Signature;
class SignedMessage;
class SymmetriclyEncryptedMessage;

enum SignatureType {
  SHA512withECDSA = 0,
  SHA512withEd25519 = 1,
  SignatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SignatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SignatureType_IsValid(int value);
const SignatureType SignatureType_MIN = SHA512withECDSA;
const SignatureType SignatureType_MAX = SHA512withEd25519;
const int SignatureType_ARRAYSIZE = SignatureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignatureType_descriptor();
inline const ::std::string& SignatureType_Name(SignatureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignatureType_descriptor(), value);
}
inline bool SignatureType_Parse(
    const ::std::string& name, SignatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignatureType>(
    SignatureType_descriptor(), name, value);
}
enum AsymmetricKeyType {
  secp384r1 = 0,
  secp521r1 = 1,
  EdDSA_256 = 2,
  AsymmetricKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AsymmetricKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AsymmetricKeyType_IsValid(int value);
const AsymmetricKeyType AsymmetricKeyType_MIN = secp384r1;
const AsymmetricKeyType AsymmetricKeyType_MAX = EdDSA_256;
const int AsymmetricKeyType_ARRAYSIZE = AsymmetricKeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AsymmetricKeyType_descriptor();
inline const ::std::string& AsymmetricKeyType_Name(AsymmetricKeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AsymmetricKeyType_descriptor(), value);
}
inline bool AsymmetricKeyType_Parse(
    const ::std::string& name, AsymmetricKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsymmetricKeyType>(
    AsymmetricKeyType_descriptor(), name, value);
}
enum SymmetricKeyType {
  AES_256_GCM_PBKDF2WithHmacSHA256_65536_128 = 0,
  SymmetricKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SymmetricKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SymmetricKeyType_IsValid(int value);
const SymmetricKeyType SymmetricKeyType_MIN = AES_256_GCM_PBKDF2WithHmacSHA256_65536_128;
const SymmetricKeyType SymmetricKeyType_MAX = AES_256_GCM_PBKDF2WithHmacSHA256_65536_128;
const int SymmetricKeyType_ARRAYSIZE = SymmetricKeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SymmetricKeyType_descriptor();
inline const ::std::string& SymmetricKeyType_Name(SymmetricKeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SymmetricKeyType_descriptor(), value);
}
inline bool SymmetricKeyType_Parse(
    const ::std::string& name, SymmetricKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SymmetricKeyType>(
    SymmetricKeyType_descriptor(), name, value);
}
enum KeyEncodingType {
  pkcs8 = 0,
  x509 = 1,
  KeyEncodingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KeyEncodingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KeyEncodingType_IsValid(int value);
const KeyEncodingType KeyEncodingType_MIN = pkcs8;
const KeyEncodingType KeyEncodingType_MAX = x509;
const int KeyEncodingType_ARRAYSIZE = KeyEncodingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEncodingType_descriptor();
inline const ::std::string& KeyEncodingType_Name(KeyEncodingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEncodingType_descriptor(), value);
}
inline bool KeyEncodingType_Parse(
    const ::std::string& name, KeyEncodingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEncodingType>(
    KeyEncodingType_descriptor(), name, value);
}
enum ImageType {
  jpeg = 0,
  ImageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageType_IsValid(int value);
const ImageType ImageType_MIN = jpeg;
const ImageType ImageType_MAX = jpeg;
const int ImageType_ARRAYSIZE = ImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageType_descriptor();
inline const ::std::string& ImageType_Name(ImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageType_descriptor(), value);
}
inline bool ImageType_Parse(
    const ::std::string& name, ImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageType>(
    ImageType_descriptor(), name, value);
}
enum MessageType {
  MessagePost = 0,
  MessageSignature = 1,
  MessagePrivateKey = 2,
  MessagePublicKey = 3,
  MessageSymmetriclyEncryptedMessage = 4,
  MessageAsymmetriclyEncryptedMessage = 5,
  MessageHybridEncryptedMessage = 6,
  MessageReferenceMessage = 7,
  MessageSymetricKey = 100,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MessagePost;
const MessageType MessageType_MAX = MessageSymetricKey;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  inline Image* New() const { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes image = 1;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // optional .ImageType imageType = 2;
  void clear_imagetype();
  static const int kImageTypeFieldNumber = 2;
  ::ImageType imagetype() const;
  void set_imagetype(::ImageType value);

  // @@protoc_insertion_point(class_scope:Image)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  int imagetype_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class Post : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Post) */ {
 public:
  Post();
  virtual ~Post();

  Post(const Post& from);

  inline Post& operator=(const Post& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Post& default_instance();

  void Swap(Post* other);

  // implements Message ----------------------------------------------

  inline Post* New() const { return New(NULL); }

  Post* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Post& from);
  void MergeFrom(const Post& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Post* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string location = 4;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional fixed64 start_time = 5;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 5;
  ::google::protobuf::uint64 start_time() const;
  void set_start_time(::google::protobuf::uint64 value);

  // optional bool all_day = 6;
  void clear_all_day();
  static const int kAllDayFieldNumber = 6;
  bool all_day() const;
  void set_all_day(bool value);

  // optional fixed64 end_time = 7;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 7;
  ::google::protobuf::uint64 end_time() const;
  void set_end_time(::google::protobuf::uint64 value);

  // optional .Image image = 8;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 8;
  const ::Image& image() const;
  ::Image* mutable_image();
  ::Image* release_image();
  void set_allocated_image(::Image* image);

  // optional fixed64 rsvp_by = 9;
  void clear_rsvp_by();
  static const int kRsvpByFieldNumber = 9;
  ::google::protobuf::uint64 rsvp_by() const;
  void set_rsvp_by(::google::protobuf::uint64 value);

  // optional string rsvp_email = 10;
  void clear_rsvp_email();
  static const int kRsvpEmailFieldNumber = 10;
  const ::std::string& rsvp_email() const;
  void set_rsvp_email(const ::std::string& value);
  void set_rsvp_email(const char* value);
  void set_rsvp_email(const char* value, size_t size);
  ::std::string* mutable_rsvp_email();
  ::std::string* release_rsvp_email();
  void set_allocated_rsvp_email(::std::string* rsvp_email);

  // optional fixed64 timestamp = 11;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Post)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::uint64 start_time_;
  ::google::protobuf::uint64 end_time_;
  ::Image* image_;
  ::google::protobuf::uint64 rsvp_by_;
  ::google::protobuf::internal::ArenaStringPtr rsvp_email_;
  ::google::protobuf::uint64 timestamp_;
  bool all_day_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Post* default_instance_;
};
// -------------------------------------------------------------------

class Signature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Signature) */ {
 public:
  Signature();
  virtual ~Signature();

  Signature(const Signature& from);

  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signature& default_instance();

  void Swap(Signature* other);

  // implements Message ----------------------------------------------

  inline Signature* New() const { return New(NULL); }

  Signature* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signature& from);
  void MergeFrom(const Signature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional .SignatureType signature_type = 3;
  void clear_signature_type();
  static const int kSignatureTypeFieldNumber = 3;
  ::SignatureType signature_type() const;
  void set_signature_type(::SignatureType value);

  // optional bytes id = 5;
  void clear_id();
  static const int kIdFieldNumber = 5;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .KeyId key_id = 6;
  bool has_key_id() const;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 6;
  const ::KeyId& key_id() const;
  ::KeyId* mutable_key_id();
  ::KeyId* release_key_id();
  void set_allocated_key_id(::KeyId* key_id);

  // @@protoc_insertion_point(class_scope:Signature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::KeyId* key_id_;
  int signature_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Signature* default_instance_;
};
// -------------------------------------------------------------------

class DistinguishedName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DistinguishedName) */ {
 public:
  DistinguishedName();
  virtual ~DistinguishedName();

  DistinguishedName(const DistinguishedName& from);

  inline DistinguishedName& operator=(const DistinguishedName& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DistinguishedName& default_instance();

  void Swap(DistinguishedName* other);

  // implements Message ----------------------------------------------

  inline DistinguishedName* New() const { return New(NULL); }

  DistinguishedName* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DistinguishedName& from);
  void MergeFrom(const DistinguishedName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DistinguishedName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string country = 1;
  void clear_country();
  static const int kCountryFieldNumber = 1;
  const ::std::string& country() const;
  void set_country(const ::std::string& value);
  void set_country(const char* value);
  void set_country(const char* value, size_t size);
  ::std::string* mutable_country();
  ::std::string* release_country();
  void set_allocated_country(::std::string* country);

  // optional string organization = 2;
  void clear_organization();
  static const int kOrganizationFieldNumber = 2;
  const ::std::string& organization() const;
  void set_organization(const ::std::string& value);
  void set_organization(const char* value);
  void set_organization(const char* value, size_t size);
  ::std::string* mutable_organization();
  ::std::string* release_organization();
  void set_allocated_organization(::std::string* organization);

  // optional string organizational_unit = 3;
  void clear_organizational_unit();
  static const int kOrganizationalUnitFieldNumber = 3;
  const ::std::string& organizational_unit() const;
  void set_organizational_unit(const ::std::string& value);
  void set_organizational_unit(const char* value);
  void set_organizational_unit(const char* value, size_t size);
  ::std::string* mutable_organizational_unit();
  ::std::string* release_organizational_unit();
  void set_allocated_organizational_unit(::std::string* organizational_unit);

  // optional string distinguished_name_qualifier = 4;
  void clear_distinguished_name_qualifier();
  static const int kDistinguishedNameQualifierFieldNumber = 4;
  const ::std::string& distinguished_name_qualifier() const;
  void set_distinguished_name_qualifier(const ::std::string& value);
  void set_distinguished_name_qualifier(const char* value);
  void set_distinguished_name_qualifier(const char* value, size_t size);
  ::std::string* mutable_distinguished_name_qualifier();
  ::std::string* release_distinguished_name_qualifier();
  void set_allocated_distinguished_name_qualifier(::std::string* distinguished_name_qualifier);

  // optional string state = 5;
  void clear_state();
  static const int kStateFieldNumber = 5;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // optional string common_name = 6;
  void clear_common_name();
  static const int kCommonNameFieldNumber = 6;
  const ::std::string& common_name() const;
  void set_common_name(const ::std::string& value);
  void set_common_name(const char* value);
  void set_common_name(const char* value, size_t size);
  ::std::string* mutable_common_name();
  ::std::string* release_common_name();
  void set_allocated_common_name(::std::string* common_name);

  // optional string serial_number = 7;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 7;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // optional string email = 8;
  void clear_email();
  static const int kEmailFieldNumber = 8;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:DistinguishedName)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr country_;
  ::google::protobuf::internal::ArenaStringPtr organization_;
  ::google::protobuf::internal::ArenaStringPtr organizational_unit_;
  ::google::protobuf::internal::ArenaStringPtr distinguished_name_qualifier_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr common_name_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static DistinguishedName* default_instance_;
};
// -------------------------------------------------------------------

class KeyId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyId) */ {
 public:
  KeyId();
  virtual ~KeyId();

  KeyId(const KeyId& from);

  inline KeyId& operator=(const KeyId& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyId& default_instance();

  void Swap(KeyId* other);

  // implements Message ----------------------------------------------

  inline KeyId* New() const { return New(NULL); }

  KeyId* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyId& from);
  void MergeFrom(const KeyId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes fingerprint_sha512 = 1;
  void clear_fingerprint_sha512();
  static const int kFingerprintSha512FieldNumber = 1;
  const ::std::string& fingerprint_sha512() const;
  void set_fingerprint_sha512(const ::std::string& value);
  void set_fingerprint_sha512(const char* value);
  void set_fingerprint_sha512(const void* value, size_t size);
  ::std::string* mutable_fingerprint_sha512();
  ::std::string* release_fingerprint_sha512();
  void set_allocated_fingerprint_sha512(::std::string* fingerprint_sha512);

  // optional .DistinguishedName dn = 2;
  bool has_dn() const;
  void clear_dn();
  static const int kDnFieldNumber = 2;
  const ::DistinguishedName& dn() const;
  ::DistinguishedName* mutable_dn();
  ::DistinguishedName* release_dn();
  void set_allocated_dn(::DistinguishedName* dn);

  // optional .AsymmetricKeyType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::AsymmetricKeyType type() const;
  void set_type(::AsymmetricKeyType value);

  // @@protoc_insertion_point(class_scope:KeyId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr fingerprint_sha512_;
  ::DistinguishedName* dn_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static KeyId* default_instance_;
};
// -------------------------------------------------------------------

class PrivateKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PrivateKey) */ {
 public:
  PrivateKey();
  virtual ~PrivateKey();

  PrivateKey(const PrivateKey& from);

  inline PrivateKey& operator=(const PrivateKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateKey& default_instance();

  void Swap(PrivateKey* other);

  // implements Message ----------------------------------------------

  inline PrivateKey* New() const { return New(NULL); }

  PrivateKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivateKey& from);
  void MergeFrom(const PrivateKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SymmetriclyEncryptedMessage key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::SymmetriclyEncryptedMessage& key() const;
  ::SymmetriclyEncryptedMessage* mutable_key();
  ::SymmetriclyEncryptedMessage* release_key();
  void set_allocated_key(::SymmetriclyEncryptedMessage* key);

  // optional .KeyEncodingType encodingType = 5;
  void clear_encodingtype();
  static const int kEncodingTypeFieldNumber = 5;
  ::KeyEncodingType encodingtype() const;
  void set_encodingtype(::KeyEncodingType value);

  // optional .KeyId key_id = 6;
  bool has_key_id() const;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 6;
  const ::KeyId& key_id() const;
  ::KeyId* mutable_key_id();
  ::KeyId* release_key_id();
  void set_allocated_key_id(::KeyId* key_id);

  // optional bytes id = 7;
  void clear_id();
  static const int kIdFieldNumber = 7;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:PrivateKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::SymmetriclyEncryptedMessage* key_;
  ::KeyId* key_id_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int encodingtype_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static PrivateKey* default_instance_;
};
// -------------------------------------------------------------------

class PublicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PublicKey) */ {
 public:
  PublicKey();
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicKey& default_instance();

  void Swap(PublicKey* other);

  // implements Message ----------------------------------------------

  inline PublicKey* New() const { return New(NULL); }

  PublicKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .KeyEncodingType encodingType = 4;
  void clear_encodingtype();
  static const int kEncodingTypeFieldNumber = 4;
  ::KeyEncodingType encodingtype() const;
  void set_encodingtype(::KeyEncodingType value);

  // optional .KeyId key_id = 5;
  bool has_key_id() const;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 5;
  const ::KeyId& key_id() const;
  ::KeyId* mutable_key_id();
  ::KeyId* release_key_id();
  void set_allocated_key_id(::KeyId* key_id);

  // optional bytes id = 6;
  void clear_id();
  static const int kIdFieldNumber = 6;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:PublicKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::KeyId* key_id_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int encodingtype_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static PublicKey* default_instance_;
};
// -------------------------------------------------------------------

class SymmetriclyEncryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SymmetriclyEncryptedMessage) */ {
 public:
  SymmetriclyEncryptedMessage();
  virtual ~SymmetriclyEncryptedMessage();

  SymmetriclyEncryptedMessage(const SymmetriclyEncryptedMessage& from);

  inline SymmetriclyEncryptedMessage& operator=(const SymmetriclyEncryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymmetriclyEncryptedMessage& default_instance();

  void Swap(SymmetriclyEncryptedMessage* other);

  // implements Message ----------------------------------------------

  inline SymmetriclyEncryptedMessage* New() const { return New(NULL); }

  SymmetriclyEncryptedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymmetriclyEncryptedMessage& from);
  void MergeFrom(const SymmetriclyEncryptedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SymmetriclyEncryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MessageType message_type = 1;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  ::MessageType message_type() const;
  void set_message_type(::MessageType value);

  // optional .SymmetricKeyType encryption_type = 2;
  void clear_encryption_type();
  static const int kEncryptionTypeFieldNumber = 2;
  ::SymmetricKeyType encryption_type() const;
  void set_encryption_type(::SymmetricKeyType value);

  // optional bytes msg = 3;
  void clear_msg();
  static const int kMsgFieldNumber = 3;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional bytes iv = 4;
  void clear_iv();
  static const int kIvFieldNumber = 4;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional bytes salt = 5;
  void clear_salt();
  static const int kSaltFieldNumber = 5;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // optional bytes id = 6;
  void clear_id();
  static const int kIdFieldNumber = 6;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:SymmetriclyEncryptedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int message_type_;
  int encryption_type_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SymmetriclyEncryptedMessage* default_instance_;
};
// -------------------------------------------------------------------

class AsymmetriclyEncryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AsymmetriclyEncryptedMessage) */ {
 public:
  AsymmetriclyEncryptedMessage();
  virtual ~AsymmetriclyEncryptedMessage();

  AsymmetriclyEncryptedMessage(const AsymmetriclyEncryptedMessage& from);

  inline AsymmetriclyEncryptedMessage& operator=(const AsymmetriclyEncryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AsymmetriclyEncryptedMessage& default_instance();

  void Swap(AsymmetriclyEncryptedMessage* other);

  // implements Message ----------------------------------------------

  inline AsymmetriclyEncryptedMessage* New() const { return New(NULL); }

  AsymmetriclyEncryptedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AsymmetriclyEncryptedMessage& from);
  void MergeFrom(const AsymmetriclyEncryptedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AsymmetriclyEncryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MessageType message_type = 1;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  ::MessageType message_type() const;
  void set_message_type(::MessageType value);

  // optional .KeyId dest_key = 2;
  bool has_dest_key() const;
  void clear_dest_key();
  static const int kDestKeyFieldNumber = 2;
  const ::KeyId& dest_key() const;
  ::KeyId* mutable_dest_key();
  ::KeyId* release_dest_key();
  void set_allocated_dest_key(::KeyId* dest_key);

  // optional bytes msg = 4;
  void clear_msg();
  static const int kMsgFieldNumber = 4;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional bytes id = 5;
  void clear_id();
  static const int kIdFieldNumber = 5;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:AsymmetriclyEncryptedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::KeyId* dest_key_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int message_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static AsymmetriclyEncryptedMessage* default_instance_;
};
// -------------------------------------------------------------------

class MessageReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageReference) */ {
 public:
  MessageReference();
  virtual ~MessageReference();

  MessageReference(const MessageReference& from);

  inline MessageReference& operator=(const MessageReference& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageReference& default_instance();

  void Swap(MessageReference* other);

  // implements Message ----------------------------------------------

  inline MessageReference* New() const { return New(NULL); }

  MessageReference* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageReference& from);
  void MergeFrom(const MessageReference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MessageType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::MessageType type() const;
  void set_type(::MessageType value);

  // optional bytes id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:MessageReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageReference* default_instance_;
};
// -------------------------------------------------------------------

class SignedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignedMessage) */ {
 public:
  SignedMessage();
  virtual ~SignedMessage();

  SignedMessage(const SignedMessage& from);

  inline SignedMessage& operator=(const SignedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedMessage& default_instance();

  enum MsgCase {
    kPost = 1,
    kSignedMessage = 2,
    kPrivateKey = 3,
    kPublicKey = 4,
    kSymmetriclyEncryptedMessage = 5,
    kAsymmetriclyEncryptedMessage = 6,
    kReference = 10,
    MSG_NOT_SET = 0,
  };

  void Swap(SignedMessage* other);

  // implements Message ----------------------------------------------

  inline SignedMessage* New() const { return New(NULL); }

  SignedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedMessage& from);
  void MergeFrom(const SignedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Post post = 1;
  bool has_post() const;
  void clear_post();
  static const int kPostFieldNumber = 1;
  const ::Post& post() const;
  ::Post* mutable_post();
  ::Post* release_post();
  void set_allocated_post(::Post* post);

  // optional .Signature signedMessage = 2;
  bool has_signedmessage() const;
  void clear_signedmessage();
  static const int kSignedMessageFieldNumber = 2;
  const ::Signature& signedmessage() const;
  ::Signature* mutable_signedmessage();
  ::Signature* release_signedmessage();
  void set_allocated_signedmessage(::Signature* signedmessage);

  // optional .PrivateKey privateKey = 3;
  bool has_privatekey() const;
  void clear_privatekey();
  static const int kPrivateKeyFieldNumber = 3;
  const ::PrivateKey& privatekey() const;
  ::PrivateKey* mutable_privatekey();
  ::PrivateKey* release_privatekey();
  void set_allocated_privatekey(::PrivateKey* privatekey);

  // optional .PublicKey publicKey = 4;
  bool has_publickey() const;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 4;
  const ::PublicKey& publickey() const;
  ::PublicKey* mutable_publickey();
  ::PublicKey* release_publickey();
  void set_allocated_publickey(::PublicKey* publickey);

  // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
  bool has_symmetriclyencryptedmessage() const;
  void clear_symmetriclyencryptedmessage();
  static const int kSymmetriclyEncryptedMessageFieldNumber = 5;
  const ::SymmetriclyEncryptedMessage& symmetriclyencryptedmessage() const;
  ::SymmetriclyEncryptedMessage* mutable_symmetriclyencryptedmessage();
  ::SymmetriclyEncryptedMessage* release_symmetriclyencryptedmessage();
  void set_allocated_symmetriclyencryptedmessage(::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage);

  // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
  bool has_asymmetriclyencryptedmessage() const;
  void clear_asymmetriclyencryptedmessage();
  static const int kAsymmetriclyEncryptedMessageFieldNumber = 6;
  const ::AsymmetriclyEncryptedMessage& asymmetriclyencryptedmessage() const;
  ::AsymmetriclyEncryptedMessage* mutable_asymmetriclyencryptedmessage();
  ::AsymmetriclyEncryptedMessage* release_asymmetriclyencryptedmessage();
  void set_allocated_asymmetriclyencryptedmessage(::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage);

  // optional .MessageReference reference = 10;
  bool has_reference() const;
  void clear_reference();
  static const int kReferenceFieldNumber = 10;
  const ::MessageReference& reference() const;
  ::MessageReference* mutable_reference();
  ::MessageReference* release_reference();
  void set_allocated_reference(::MessageReference* reference);

  // optional .Signature message_signature = 8;
  bool has_message_signature() const;
  void clear_message_signature();
  static const int kMessageSignatureFieldNumber = 8;
  const ::Signature& message_signature() const;
  ::Signature* mutable_message_signature();
  ::Signature* release_message_signature();
  void set_allocated_message_signature(::Signature* message_signature);

  // optional fixed64 timestamp = 9;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional bytes id = 11;
  void clear_id();
  static const int kIdFieldNumber = 11;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:SignedMessage)
 private:
  inline void set_has_post();
  inline void set_has_signedmessage();
  inline void set_has_privatekey();
  inline void set_has_publickey();
  inline void set_has_symmetriclyencryptedmessage();
  inline void set_has_asymmetriclyencryptedmessage();
  inline void set_has_reference();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Signature* message_signature_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  union MsgUnion {
    MsgUnion() {}
    ::Post* post_;
    ::Signature* signedmessage_;
    ::PrivateKey* privatekey_;
    ::PublicKey* publickey_;
    ::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage_;
    ::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage_;
    ::MessageReference* reference_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SignedMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Image

// optional bytes image = 1;
inline void Image::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Image::image() const {
  // @@protoc_insertion_point(field_get:Image.image)
  return image_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Image.image)
}
inline void Image::set_image(const char* value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Image.image)
}
inline void Image::set_image(const void* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Image.image)
}
inline ::std::string* Image::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:Image.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_image() {
  // @@protoc_insertion_point(field_release:Image.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:Image.image)
}

// optional .ImageType imageType = 2;
inline void Image::clear_imagetype() {
  imagetype_ = 0;
}
inline ::ImageType Image::imagetype() const {
  // @@protoc_insertion_point(field_get:Image.imageType)
  return static_cast< ::ImageType >(imagetype_);
}
inline void Image::set_imagetype(::ImageType value) {
  
  imagetype_ = value;
  // @@protoc_insertion_point(field_set:Image.imageType)
}

// -------------------------------------------------------------------

// Post

// optional bytes id = 1;
inline void Post::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::id() const {
  // @@protoc_insertion_point(field_get:Post.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.id)
}
inline void Post::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.id)
}
inline void Post::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.id)
}
inline ::std::string* Post::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:Post.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_id() {
  // @@protoc_insertion_point(field_release:Post.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Post.id)
}

// optional string title = 2;
inline void Post::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::title() const {
  // @@protoc_insertion_point(field_get:Post.title)
  return title_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.title)
}
inline void Post::set_title(const char* value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.title)
}
inline void Post::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.title)
}
inline ::std::string* Post::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:Post.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_title() {
  // @@protoc_insertion_point(field_release:Post.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:Post.title)
}

// optional string description = 3;
inline void Post::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::description() const {
  // @@protoc_insertion_point(field_get:Post.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.description)
}
inline void Post::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.description)
}
inline void Post::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.description)
}
inline ::std::string* Post::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:Post.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_description() {
  // @@protoc_insertion_point(field_release:Post.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:Post.description)
}

// optional string location = 4;
inline void Post::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::location() const {
  // @@protoc_insertion_point(field_get:Post.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.location)
}
inline void Post::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.location)
}
inline void Post::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.location)
}
inline ::std::string* Post::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Post.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_location() {
  // @@protoc_insertion_point(field_release:Post.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Post.location)
}

// optional fixed64 start_time = 5;
inline void Post::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Post::start_time() const {
  // @@protoc_insertion_point(field_get:Post.start_time)
  return start_time_;
}
inline void Post::set_start_time(::google::protobuf::uint64 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:Post.start_time)
}

// optional bool all_day = 6;
inline void Post::clear_all_day() {
  all_day_ = false;
}
inline bool Post::all_day() const {
  // @@protoc_insertion_point(field_get:Post.all_day)
  return all_day_;
}
inline void Post::set_all_day(bool value) {
  
  all_day_ = value;
  // @@protoc_insertion_point(field_set:Post.all_day)
}

// optional fixed64 end_time = 7;
inline void Post::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Post::end_time() const {
  // @@protoc_insertion_point(field_get:Post.end_time)
  return end_time_;
}
inline void Post::set_end_time(::google::protobuf::uint64 value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:Post.end_time)
}

// optional .Image image = 8;
inline bool Post::has_image() const {
  return !_is_default_instance_ && image_ != NULL;
}
inline void Post::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::Image& Post::image() const {
  // @@protoc_insertion_point(field_get:Post.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::Image* Post::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::Image;
  }
  // @@protoc_insertion_point(field_mutable:Post.image)
  return image_;
}
inline ::Image* Post::release_image() {
  // @@protoc_insertion_point(field_release:Post.image)
  
  ::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void Post::set_allocated_image(::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Post.image)
}

// optional fixed64 rsvp_by = 9;
inline void Post::clear_rsvp_by() {
  rsvp_by_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Post::rsvp_by() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_by)
  return rsvp_by_;
}
inline void Post::set_rsvp_by(::google::protobuf::uint64 value) {
  
  rsvp_by_ = value;
  // @@protoc_insertion_point(field_set:Post.rsvp_by)
}

// optional string rsvp_email = 10;
inline void Post::clear_rsvp_email() {
  rsvp_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::rsvp_email() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_email)
  return rsvp_email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_rsvp_email(const ::std::string& value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.rsvp_email)
}
inline void Post::set_rsvp_email(const char* value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.rsvp_email)
}
inline void Post::set_rsvp_email(const char* value, size_t size) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.rsvp_email)
}
inline ::std::string* Post::mutable_rsvp_email() {
  
  // @@protoc_insertion_point(field_mutable:Post.rsvp_email)
  return rsvp_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_rsvp_email() {
  // @@protoc_insertion_point(field_release:Post.rsvp_email)
  
  return rsvp_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_rsvp_email(::std::string* rsvp_email) {
  if (rsvp_email != NULL) {
    
  } else {
    
  }
  rsvp_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rsvp_email);
  // @@protoc_insertion_point(field_set_allocated:Post.rsvp_email)
}

// optional fixed64 timestamp = 11;
inline void Post::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Post::timestamp() const {
  // @@protoc_insertion_point(field_get:Post.timestamp)
  return timestamp_;
}
inline void Post::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Post.timestamp)
}

// -------------------------------------------------------------------

// Signature

// optional bytes signature = 2;
inline void Signature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signature::signature() const {
  // @@protoc_insertion_point(field_get:Signature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.signature)
}
inline void Signature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.signature)
}
inline void Signature::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.signature)
}
inline ::std::string* Signature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Signature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signature::release_signature() {
  // @@protoc_insertion_point(field_release:Signature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Signature.signature)
}

// optional .SignatureType signature_type = 3;
inline void Signature::clear_signature_type() {
  signature_type_ = 0;
}
inline ::SignatureType Signature::signature_type() const {
  // @@protoc_insertion_point(field_get:Signature.signature_type)
  return static_cast< ::SignatureType >(signature_type_);
}
inline void Signature::set_signature_type(::SignatureType value) {
  
  signature_type_ = value;
  // @@protoc_insertion_point(field_set:Signature.signature_type)
}

// optional bytes id = 5;
inline void Signature::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signature::id() const {
  // @@protoc_insertion_point(field_get:Signature.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.id)
}
inline void Signature::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.id)
}
inline void Signature::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.id)
}
inline ::std::string* Signature::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:Signature.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signature::release_id() {
  // @@protoc_insertion_point(field_release:Signature.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Signature.id)
}

// optional .KeyId key_id = 6;
inline bool Signature::has_key_id() const {
  return !_is_default_instance_ && key_id_ != NULL;
}
inline void Signature::clear_key_id() {
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
}
inline const ::KeyId& Signature::key_id() const {
  // @@protoc_insertion_point(field_get:Signature.key_id)
  return key_id_ != NULL ? *key_id_ : *default_instance_->key_id_;
}
inline ::KeyId* Signature::mutable_key_id() {
  
  if (key_id_ == NULL) {
    key_id_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:Signature.key_id)
  return key_id_;
}
inline ::KeyId* Signature::release_key_id() {
  // @@protoc_insertion_point(field_release:Signature.key_id)
  
  ::KeyId* temp = key_id_;
  key_id_ = NULL;
  return temp;
}
inline void Signature::set_allocated_key_id(::KeyId* key_id) {
  delete key_id_;
  key_id_ = key_id;
  if (key_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Signature.key_id)
}

// -------------------------------------------------------------------

// DistinguishedName

// optional string country = 1;
inline void DistinguishedName::clear_country() {
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::country() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.country)
  return country_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_country(const ::std::string& value) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.country)
}
inline void DistinguishedName::set_country(const char* value) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.country)
}
inline void DistinguishedName::set_country(const char* value, size_t size) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.country)
}
inline ::std::string* DistinguishedName::mutable_country() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.country)
  return country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_country() {
  // @@protoc_insertion_point(field_release:DistinguishedName.country)
  
  return country_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_country(::std::string* country) {
  if (country != NULL) {
    
  } else {
    
  }
  country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.country)
}

// optional string organization = 2;
inline void DistinguishedName::clear_organization() {
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::organization() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.organization)
  return organization_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_organization(const ::std::string& value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.organization)
}
inline void DistinguishedName::set_organization(const char* value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.organization)
}
inline void DistinguishedName::set_organization(const char* value, size_t size) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.organization)
}
inline ::std::string* DistinguishedName::mutable_organization() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.organization)
  return organization_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_organization() {
  // @@protoc_insertion_point(field_release:DistinguishedName.organization)
  
  return organization_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_organization(::std::string* organization) {
  if (organization != NULL) {
    
  } else {
    
  }
  organization_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organization);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.organization)
}

// optional string organizational_unit = 3;
inline void DistinguishedName::clear_organizational_unit() {
  organizational_unit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::organizational_unit() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.organizational_unit)
  return organizational_unit_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_organizational_unit(const ::std::string& value) {
  
  organizational_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.organizational_unit)
}
inline void DistinguishedName::set_organizational_unit(const char* value) {
  
  organizational_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.organizational_unit)
}
inline void DistinguishedName::set_organizational_unit(const char* value, size_t size) {
  
  organizational_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.organizational_unit)
}
inline ::std::string* DistinguishedName::mutable_organizational_unit() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.organizational_unit)
  return organizational_unit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_organizational_unit() {
  // @@protoc_insertion_point(field_release:DistinguishedName.organizational_unit)
  
  return organizational_unit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_organizational_unit(::std::string* organizational_unit) {
  if (organizational_unit != NULL) {
    
  } else {
    
  }
  organizational_unit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organizational_unit);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.organizational_unit)
}

// optional string distinguished_name_qualifier = 4;
inline void DistinguishedName::clear_distinguished_name_qualifier() {
  distinguished_name_qualifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::distinguished_name_qualifier() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.distinguished_name_qualifier)
  return distinguished_name_qualifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_distinguished_name_qualifier(const ::std::string& value) {
  
  distinguished_name_qualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.distinguished_name_qualifier)
}
inline void DistinguishedName::set_distinguished_name_qualifier(const char* value) {
  
  distinguished_name_qualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.distinguished_name_qualifier)
}
inline void DistinguishedName::set_distinguished_name_qualifier(const char* value, size_t size) {
  
  distinguished_name_qualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.distinguished_name_qualifier)
}
inline ::std::string* DistinguishedName::mutable_distinguished_name_qualifier() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.distinguished_name_qualifier)
  return distinguished_name_qualifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_distinguished_name_qualifier() {
  // @@protoc_insertion_point(field_release:DistinguishedName.distinguished_name_qualifier)
  
  return distinguished_name_qualifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_distinguished_name_qualifier(::std::string* distinguished_name_qualifier) {
  if (distinguished_name_qualifier != NULL) {
    
  } else {
    
  }
  distinguished_name_qualifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), distinguished_name_qualifier);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.distinguished_name_qualifier)
}

// optional string state = 5;
inline void DistinguishedName::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::state() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.state)
  return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.state)
}
inline void DistinguishedName::set_state(const char* value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.state)
}
inline void DistinguishedName::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.state)
}
inline ::std::string* DistinguishedName::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_state() {
  // @@protoc_insertion_point(field_release:DistinguishedName.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.state)
}

// optional string common_name = 6;
inline void DistinguishedName::clear_common_name() {
  common_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::common_name() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.common_name)
  return common_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_common_name(const ::std::string& value) {
  
  common_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.common_name)
}
inline void DistinguishedName::set_common_name(const char* value) {
  
  common_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.common_name)
}
inline void DistinguishedName::set_common_name(const char* value, size_t size) {
  
  common_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.common_name)
}
inline ::std::string* DistinguishedName::mutable_common_name() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.common_name)
  return common_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_common_name() {
  // @@protoc_insertion_point(field_release:DistinguishedName.common_name)
  
  return common_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_common_name(::std::string* common_name) {
  if (common_name != NULL) {
    
  } else {
    
  }
  common_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), common_name);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.common_name)
}

// optional string serial_number = 7;
inline void DistinguishedName::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::serial_number() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.serial_number)
  return serial_number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.serial_number)
}
inline void DistinguishedName::set_serial_number(const char* value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.serial_number)
}
inline void DistinguishedName::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.serial_number)
}
inline ::std::string* DistinguishedName::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_serial_number() {
  // @@protoc_insertion_point(field_release:DistinguishedName.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.serial_number)
}

// optional string email = 8;
inline void DistinguishedName::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistinguishedName::email() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.email)
  return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.email)
}
inline void DistinguishedName::set_email(const char* value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.email)
}
inline void DistinguishedName::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.email)
}
inline ::std::string* DistinguishedName::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistinguishedName::release_email() {
  // @@protoc_insertion_point(field_release:DistinguishedName.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistinguishedName::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.email)
}

// -------------------------------------------------------------------

// KeyId

// optional bytes fingerprint_sha512 = 1;
inline void KeyId::clear_fingerprint_sha512() {
  fingerprint_sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyId::fingerprint_sha512() const {
  // @@protoc_insertion_point(field_get:KeyId.fingerprint_sha512)
  return fingerprint_sha512_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyId::set_fingerprint_sha512(const ::std::string& value) {
  
  fingerprint_sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyId.fingerprint_sha512)
}
inline void KeyId::set_fingerprint_sha512(const char* value) {
  
  fingerprint_sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyId.fingerprint_sha512)
}
inline void KeyId::set_fingerprint_sha512(const void* value, size_t size) {
  
  fingerprint_sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyId.fingerprint_sha512)
}
inline ::std::string* KeyId::mutable_fingerprint_sha512() {
  
  // @@protoc_insertion_point(field_mutable:KeyId.fingerprint_sha512)
  return fingerprint_sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyId::release_fingerprint_sha512() {
  // @@protoc_insertion_point(field_release:KeyId.fingerprint_sha512)
  
  return fingerprint_sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyId::set_allocated_fingerprint_sha512(::std::string* fingerprint_sha512) {
  if (fingerprint_sha512 != NULL) {
    
  } else {
    
  }
  fingerprint_sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fingerprint_sha512);
  // @@protoc_insertion_point(field_set_allocated:KeyId.fingerprint_sha512)
}

// optional .DistinguishedName dn = 2;
inline bool KeyId::has_dn() const {
  return !_is_default_instance_ && dn_ != NULL;
}
inline void KeyId::clear_dn() {
  if (GetArenaNoVirtual() == NULL && dn_ != NULL) delete dn_;
  dn_ = NULL;
}
inline const ::DistinguishedName& KeyId::dn() const {
  // @@protoc_insertion_point(field_get:KeyId.dn)
  return dn_ != NULL ? *dn_ : *default_instance_->dn_;
}
inline ::DistinguishedName* KeyId::mutable_dn() {
  
  if (dn_ == NULL) {
    dn_ = new ::DistinguishedName;
  }
  // @@protoc_insertion_point(field_mutable:KeyId.dn)
  return dn_;
}
inline ::DistinguishedName* KeyId::release_dn() {
  // @@protoc_insertion_point(field_release:KeyId.dn)
  
  ::DistinguishedName* temp = dn_;
  dn_ = NULL;
  return temp;
}
inline void KeyId::set_allocated_dn(::DistinguishedName* dn) {
  delete dn_;
  dn_ = dn;
  if (dn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:KeyId.dn)
}

// optional .AsymmetricKeyType type = 3;
inline void KeyId::clear_type() {
  type_ = 0;
}
inline ::AsymmetricKeyType KeyId::type() const {
  // @@protoc_insertion_point(field_get:KeyId.type)
  return static_cast< ::AsymmetricKeyType >(type_);
}
inline void KeyId::set_type(::AsymmetricKeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:KeyId.type)
}

// -------------------------------------------------------------------

// PrivateKey

// optional .SymmetriclyEncryptedMessage key = 2;
inline bool PrivateKey::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void PrivateKey::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::SymmetriclyEncryptedMessage& PrivateKey::key() const {
  // @@protoc_insertion_point(field_get:PrivateKey.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::SymmetriclyEncryptedMessage* PrivateKey::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:PrivateKey.key)
  return key_;
}
inline ::SymmetriclyEncryptedMessage* PrivateKey::release_key() {
  // @@protoc_insertion_point(field_release:PrivateKey.key)
  
  ::SymmetriclyEncryptedMessage* temp = key_;
  key_ = NULL;
  return temp;
}
inline void PrivateKey::set_allocated_key(::SymmetriclyEncryptedMessage* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.key)
}

// optional .KeyEncodingType encodingType = 5;
inline void PrivateKey::clear_encodingtype() {
  encodingtype_ = 0;
}
inline ::KeyEncodingType PrivateKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PrivateKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
inline void PrivateKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PrivateKey.encodingType)
}

// optional .KeyId key_id = 6;
inline bool PrivateKey::has_key_id() const {
  return !_is_default_instance_ && key_id_ != NULL;
}
inline void PrivateKey::clear_key_id() {
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
}
inline const ::KeyId& PrivateKey::key_id() const {
  // @@protoc_insertion_point(field_get:PrivateKey.key_id)
  return key_id_ != NULL ? *key_id_ : *default_instance_->key_id_;
}
inline ::KeyId* PrivateKey::mutable_key_id() {
  
  if (key_id_ == NULL) {
    key_id_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:PrivateKey.key_id)
  return key_id_;
}
inline ::KeyId* PrivateKey::release_key_id() {
  // @@protoc_insertion_point(field_release:PrivateKey.key_id)
  
  ::KeyId* temp = key_id_;
  key_id_ = NULL;
  return temp;
}
inline void PrivateKey::set_allocated_key_id(::KeyId* key_id) {
  delete key_id_;
  key_id_ = key_id;
  if (key_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.key_id)
}

// optional bytes id = 7;
inline void PrivateKey::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateKey::id() const {
  // @@protoc_insertion_point(field_get:PrivateKey.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.id)
}
inline void PrivateKey::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.id)
}
inline void PrivateKey::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.id)
}
inline ::std::string* PrivateKey::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateKey::release_id() {
  // @@protoc_insertion_point(field_release:PrivateKey.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.id)
}

// -------------------------------------------------------------------

// PublicKey

// optional bytes key = 2;
inline void PublicKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicKey::key() const {
  // @@protoc_insertion_point(field_get:PublicKey.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.key)
}
inline void PublicKey::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.key)
}
inline void PublicKey::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.key)
}
inline ::std::string* PublicKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKey::release_key() {
  // @@protoc_insertion_point(field_release:PublicKey.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.key)
}

// optional .KeyEncodingType encodingType = 4;
inline void PublicKey::clear_encodingtype() {
  encodingtype_ = 0;
}
inline ::KeyEncodingType PublicKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PublicKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
inline void PublicKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PublicKey.encodingType)
}

// optional .KeyId key_id = 5;
inline bool PublicKey::has_key_id() const {
  return !_is_default_instance_ && key_id_ != NULL;
}
inline void PublicKey::clear_key_id() {
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
}
inline const ::KeyId& PublicKey::key_id() const {
  // @@protoc_insertion_point(field_get:PublicKey.key_id)
  return key_id_ != NULL ? *key_id_ : *default_instance_->key_id_;
}
inline ::KeyId* PublicKey::mutable_key_id() {
  
  if (key_id_ == NULL) {
    key_id_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:PublicKey.key_id)
  return key_id_;
}
inline ::KeyId* PublicKey::release_key_id() {
  // @@protoc_insertion_point(field_release:PublicKey.key_id)
  
  ::KeyId* temp = key_id_;
  key_id_ = NULL;
  return temp;
}
inline void PublicKey::set_allocated_key_id(::KeyId* key_id) {
  delete key_id_;
  key_id_ = key_id;
  if (key_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PublicKey.key_id)
}

// optional bytes id = 6;
inline void PublicKey::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicKey::id() const {
  // @@protoc_insertion_point(field_get:PublicKey.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.id)
}
inline void PublicKey::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.id)
}
inline void PublicKey::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.id)
}
inline ::std::string* PublicKey::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKey::release_id() {
  // @@protoc_insertion_point(field_release:PublicKey.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.id)
}

// -------------------------------------------------------------------

// SymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
inline void SymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
inline ::MessageType SymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
inline void SymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.message_type)
}

// optional .SymmetricKeyType encryption_type = 2;
inline void SymmetriclyEncryptedMessage::clear_encryption_type() {
  encryption_type_ = 0;
}
inline ::SymmetricKeyType SymmetriclyEncryptedMessage::encryption_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.encryption_type)
  return static_cast< ::SymmetricKeyType >(encryption_type_);
}
inline void SymmetriclyEncryptedMessage::set_encryption_type(::SymmetricKeyType value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.encryption_type)
}

// optional bytes msg = 3;
inline void SymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.msg)
}
inline void SymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.msg)
}
inline void SymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.msg)
}
inline ::std::string* SymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.msg)
}

// optional bytes iv = 4;
inline void SymmetriclyEncryptedMessage::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymmetriclyEncryptedMessage::iv() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.iv)
}
inline void SymmetriclyEncryptedMessage::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.iv)
}
inline void SymmetriclyEncryptedMessage::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.iv)
}
inline ::std::string* SymmetriclyEncryptedMessage::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymmetriclyEncryptedMessage::release_iv() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.iv)
}

// optional bytes salt = 5;
inline void SymmetriclyEncryptedMessage::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymmetriclyEncryptedMessage::salt() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.salt)
  return salt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.salt)
}
inline void SymmetriclyEncryptedMessage::set_salt(const char* value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.salt)
}
inline void SymmetriclyEncryptedMessage::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.salt)
}
inline ::std::string* SymmetriclyEncryptedMessage::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymmetriclyEncryptedMessage::release_salt() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.salt)
}

// optional bytes id = 6;
inline void SymmetriclyEncryptedMessage::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymmetriclyEncryptedMessage::id() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.id)
}
inline void SymmetriclyEncryptedMessage::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.id)
}
inline void SymmetriclyEncryptedMessage::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.id)
}
inline ::std::string* SymmetriclyEncryptedMessage::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymmetriclyEncryptedMessage::release_id() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.id)
}

// -------------------------------------------------------------------

// AsymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
inline void AsymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
inline ::MessageType AsymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
inline void AsymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.message_type)
}

// optional .KeyId dest_key = 2;
inline bool AsymmetriclyEncryptedMessage::has_dest_key() const {
  return !_is_default_instance_ && dest_key_ != NULL;
}
inline void AsymmetriclyEncryptedMessage::clear_dest_key() {
  if (GetArenaNoVirtual() == NULL && dest_key_ != NULL) delete dest_key_;
  dest_key_ = NULL;
}
inline const ::KeyId& AsymmetriclyEncryptedMessage::dest_key() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.dest_key)
  return dest_key_ != NULL ? *dest_key_ : *default_instance_->dest_key_;
}
inline ::KeyId* AsymmetriclyEncryptedMessage::mutable_dest_key() {
  
  if (dest_key_ == NULL) {
    dest_key_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.dest_key)
  return dest_key_;
}
inline ::KeyId* AsymmetriclyEncryptedMessage::release_dest_key() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.dest_key)
  
  ::KeyId* temp = dest_key_;
  dest_key_ = NULL;
  return temp;
}
inline void AsymmetriclyEncryptedMessage::set_allocated_dest_key(::KeyId* dest_key) {
  delete dest_key_;
  dest_key_ = dest_key;
  if (dest_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.dest_key)
}

// optional bytes msg = 4;
inline void AsymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.msg)
}
inline void AsymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.msg)
}
inline void AsymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.msg)
}
inline ::std::string* AsymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.msg)
}

// optional bytes id = 5;
inline void AsymmetriclyEncryptedMessage::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsymmetriclyEncryptedMessage::id() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.id)
}
inline void AsymmetriclyEncryptedMessage::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.id)
}
inline void AsymmetriclyEncryptedMessage::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.id)
}
inline ::std::string* AsymmetriclyEncryptedMessage::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsymmetriclyEncryptedMessage::release_id() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.id)
}

// -------------------------------------------------------------------

// MessageReference

// optional .MessageType type = 1;
inline void MessageReference::clear_type() {
  type_ = 0;
}
inline ::MessageType MessageReference::type() const {
  // @@protoc_insertion_point(field_get:MessageReference.type)
  return static_cast< ::MessageType >(type_);
}
inline void MessageReference::set_type(::MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:MessageReference.type)
}

// optional bytes id = 2;
inline void MessageReference::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageReference::id() const {
  // @@protoc_insertion_point(field_get:MessageReference.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageReference::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageReference.id)
}
inline void MessageReference::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageReference.id)
}
inline void MessageReference::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageReference.id)
}
inline ::std::string* MessageReference::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:MessageReference.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageReference::release_id() {
  // @@protoc_insertion_point(field_release:MessageReference.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageReference::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:MessageReference.id)
}

// -------------------------------------------------------------------

// SignedMessage

// optional .Post post = 1;
inline bool SignedMessage::has_post() const {
  return msg_case() == kPost;
}
inline void SignedMessage::set_has_post() {
  _oneof_case_[0] = kPost;
}
inline void SignedMessage::clear_post() {
  if (has_post()) {
    delete msg_.post_;
    clear_has_msg();
  }
}
inline  const ::Post& SignedMessage::post() const {
  // @@protoc_insertion_point(field_get:SignedMessage.post)
  return has_post()
      ? *msg_.post_
      : ::Post::default_instance();
}
inline ::Post* SignedMessage::mutable_post() {
  if (!has_post()) {
    clear_msg();
    set_has_post();
    msg_.post_ = new ::Post;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.post)
  return msg_.post_;
}
inline ::Post* SignedMessage::release_post() {
  // @@protoc_insertion_point(field_release:SignedMessage.post)
  if (has_post()) {
    clear_has_msg();
    ::Post* temp = msg_.post_;
    msg_.post_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_post(::Post* post) {
  clear_msg();
  if (post) {
    set_has_post();
    msg_.post_ = post;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.post)
}

// optional .Signature signedMessage = 2;
inline bool SignedMessage::has_signedmessage() const {
  return msg_case() == kSignedMessage;
}
inline void SignedMessage::set_has_signedmessage() {
  _oneof_case_[0] = kSignedMessage;
}
inline void SignedMessage::clear_signedmessage() {
  if (has_signedmessage()) {
    delete msg_.signedmessage_;
    clear_has_msg();
  }
}
inline  const ::Signature& SignedMessage::signedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.signedMessage)
  return has_signedmessage()
      ? *msg_.signedmessage_
      : ::Signature::default_instance();
}
inline ::Signature* SignedMessage::mutable_signedmessage() {
  if (!has_signedmessage()) {
    clear_msg();
    set_has_signedmessage();
    msg_.signedmessage_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.signedMessage)
  return msg_.signedmessage_;
}
inline ::Signature* SignedMessage::release_signedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.signedMessage)
  if (has_signedmessage()) {
    clear_has_msg();
    ::Signature* temp = msg_.signedmessage_;
    msg_.signedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_signedmessage(::Signature* signedmessage) {
  clear_msg();
  if (signedmessage) {
    set_has_signedmessage();
    msg_.signedmessage_ = signedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.signedMessage)
}

// optional .PrivateKey privateKey = 3;
inline bool SignedMessage::has_privatekey() const {
  return msg_case() == kPrivateKey;
}
inline void SignedMessage::set_has_privatekey() {
  _oneof_case_[0] = kPrivateKey;
}
inline void SignedMessage::clear_privatekey() {
  if (has_privatekey()) {
    delete msg_.privatekey_;
    clear_has_msg();
  }
}
inline  const ::PrivateKey& SignedMessage::privatekey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.privateKey)
  return has_privatekey()
      ? *msg_.privatekey_
      : ::PrivateKey::default_instance();
}
inline ::PrivateKey* SignedMessage::mutable_privatekey() {
  if (!has_privatekey()) {
    clear_msg();
    set_has_privatekey();
    msg_.privatekey_ = new ::PrivateKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.privateKey)
  return msg_.privatekey_;
}
inline ::PrivateKey* SignedMessage::release_privatekey() {
  // @@protoc_insertion_point(field_release:SignedMessage.privateKey)
  if (has_privatekey()) {
    clear_has_msg();
    ::PrivateKey* temp = msg_.privatekey_;
    msg_.privatekey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_privatekey(::PrivateKey* privatekey) {
  clear_msg();
  if (privatekey) {
    set_has_privatekey();
    msg_.privatekey_ = privatekey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.privateKey)
}

// optional .PublicKey publicKey = 4;
inline bool SignedMessage::has_publickey() const {
  return msg_case() == kPublicKey;
}
inline void SignedMessage::set_has_publickey() {
  _oneof_case_[0] = kPublicKey;
}
inline void SignedMessage::clear_publickey() {
  if (has_publickey()) {
    delete msg_.publickey_;
    clear_has_msg();
  }
}
inline  const ::PublicKey& SignedMessage::publickey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.publicKey)
  return has_publickey()
      ? *msg_.publickey_
      : ::PublicKey::default_instance();
}
inline ::PublicKey* SignedMessage::mutable_publickey() {
  if (!has_publickey()) {
    clear_msg();
    set_has_publickey();
    msg_.publickey_ = new ::PublicKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.publicKey)
  return msg_.publickey_;
}
inline ::PublicKey* SignedMessage::release_publickey() {
  // @@protoc_insertion_point(field_release:SignedMessage.publicKey)
  if (has_publickey()) {
    clear_has_msg();
    ::PublicKey* temp = msg_.publickey_;
    msg_.publickey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_publickey(::PublicKey* publickey) {
  clear_msg();
  if (publickey) {
    set_has_publickey();
    msg_.publickey_ = publickey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.publicKey)
}

// optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
inline bool SignedMessage::has_symmetriclyencryptedmessage() const {
  return msg_case() == kSymmetriclyEncryptedMessage;
}
inline void SignedMessage::set_has_symmetriclyencryptedmessage() {
  _oneof_case_[0] = kSymmetriclyEncryptedMessage;
}
inline void SignedMessage::clear_symmetriclyencryptedmessage() {
  if (has_symmetriclyencryptedmessage()) {
    delete msg_.symmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
inline  const ::SymmetriclyEncryptedMessage& SignedMessage::symmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.symmetriclyEncryptedMessage)
  return has_symmetriclyencryptedmessage()
      ? *msg_.symmetriclyencryptedmessage_
      : ::SymmetriclyEncryptedMessage::default_instance();
}
inline ::SymmetriclyEncryptedMessage* SignedMessage::mutable_symmetriclyencryptedmessage() {
  if (!has_symmetriclyencryptedmessage()) {
    clear_msg();
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.symmetriclyEncryptedMessage)
  return msg_.symmetriclyencryptedmessage_;
}
inline ::SymmetriclyEncryptedMessage* SignedMessage::release_symmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.symmetriclyEncryptedMessage)
  if (has_symmetriclyencryptedmessage()) {
    clear_has_msg();
    ::SymmetriclyEncryptedMessage* temp = msg_.symmetriclyencryptedmessage_;
    msg_.symmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_symmetriclyencryptedmessage(::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage) {
  clear_msg();
  if (symmetriclyencryptedmessage) {
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = symmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.symmetriclyEncryptedMessage)
}

// optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
inline bool SignedMessage::has_asymmetriclyencryptedmessage() const {
  return msg_case() == kAsymmetriclyEncryptedMessage;
}
inline void SignedMessage::set_has_asymmetriclyencryptedmessage() {
  _oneof_case_[0] = kAsymmetriclyEncryptedMessage;
}
inline void SignedMessage::clear_asymmetriclyencryptedmessage() {
  if (has_asymmetriclyencryptedmessage()) {
    delete msg_.asymmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
inline  const ::AsymmetriclyEncryptedMessage& SignedMessage::asymmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.asymmetriclyEncryptedMessage)
  return has_asymmetriclyencryptedmessage()
      ? *msg_.asymmetriclyencryptedmessage_
      : ::AsymmetriclyEncryptedMessage::default_instance();
}
inline ::AsymmetriclyEncryptedMessage* SignedMessage::mutable_asymmetriclyencryptedmessage() {
  if (!has_asymmetriclyencryptedmessage()) {
    clear_msg();
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = new ::AsymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.asymmetriclyEncryptedMessage)
  return msg_.asymmetriclyencryptedmessage_;
}
inline ::AsymmetriclyEncryptedMessage* SignedMessage::release_asymmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.asymmetriclyEncryptedMessage)
  if (has_asymmetriclyencryptedmessage()) {
    clear_has_msg();
    ::AsymmetriclyEncryptedMessage* temp = msg_.asymmetriclyencryptedmessage_;
    msg_.asymmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_asymmetriclyencryptedmessage(::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage) {
  clear_msg();
  if (asymmetriclyencryptedmessage) {
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = asymmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.asymmetriclyEncryptedMessage)
}

// optional .MessageReference reference = 10;
inline bool SignedMessage::has_reference() const {
  return msg_case() == kReference;
}
inline void SignedMessage::set_has_reference() {
  _oneof_case_[0] = kReference;
}
inline void SignedMessage::clear_reference() {
  if (has_reference()) {
    delete msg_.reference_;
    clear_has_msg();
  }
}
inline  const ::MessageReference& SignedMessage::reference() const {
  // @@protoc_insertion_point(field_get:SignedMessage.reference)
  return has_reference()
      ? *msg_.reference_
      : ::MessageReference::default_instance();
}
inline ::MessageReference* SignedMessage::mutable_reference() {
  if (!has_reference()) {
    clear_msg();
    set_has_reference();
    msg_.reference_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.reference)
  return msg_.reference_;
}
inline ::MessageReference* SignedMessage::release_reference() {
  // @@protoc_insertion_point(field_release:SignedMessage.reference)
  if (has_reference()) {
    clear_has_msg();
    ::MessageReference* temp = msg_.reference_;
    msg_.reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_reference(::MessageReference* reference) {
  clear_msg();
  if (reference) {
    set_has_reference();
    msg_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.reference)
}

// optional .Signature message_signature = 8;
inline bool SignedMessage::has_message_signature() const {
  return !_is_default_instance_ && message_signature_ != NULL;
}
inline void SignedMessage::clear_message_signature() {
  if (GetArenaNoVirtual() == NULL && message_signature_ != NULL) delete message_signature_;
  message_signature_ = NULL;
}
inline const ::Signature& SignedMessage::message_signature() const {
  // @@protoc_insertion_point(field_get:SignedMessage.message_signature)
  return message_signature_ != NULL ? *message_signature_ : *default_instance_->message_signature_;
}
inline ::Signature* SignedMessage::mutable_message_signature() {
  
  if (message_signature_ == NULL) {
    message_signature_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.message_signature)
  return message_signature_;
}
inline ::Signature* SignedMessage::release_message_signature() {
  // @@protoc_insertion_point(field_release:SignedMessage.message_signature)
  
  ::Signature* temp = message_signature_;
  message_signature_ = NULL;
  return temp;
}
inline void SignedMessage::set_allocated_message_signature(::Signature* message_signature) {
  delete message_signature_;
  message_signature_ = message_signature;
  if (message_signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.message_signature)
}

// optional fixed64 timestamp = 9;
inline void SignedMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SignedMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:SignedMessage.timestamp)
  return timestamp_;
}
inline void SignedMessage::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SignedMessage.timestamp)
}

// optional bytes id = 11;
inline void SignedMessage::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignedMessage::id() const {
  // @@protoc_insertion_point(field_get:SignedMessage.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedMessage::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignedMessage.id)
}
inline void SignedMessage::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignedMessage.id)
}
inline void SignedMessage::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignedMessage.id)
}
inline ::std::string* SignedMessage::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:SignedMessage.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedMessage::release_id() {
  // @@protoc_insertion_point(field_release:SignedMessage.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedMessage::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.id)
}

inline bool SignedMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void SignedMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline SignedMessage::MsgCase SignedMessage::msg_case() const {
  return SignedMessage::MsgCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SignatureType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignatureType>() {
  return ::SignatureType_descriptor();
}
template <> struct is_proto_enum< ::AsymmetricKeyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AsymmetricKeyType>() {
  return ::AsymmetricKeyType_descriptor();
}
template <> struct is_proto_enum< ::SymmetricKeyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SymmetricKeyType>() {
  return ::SymmetricKeyType_descriptor();
}
template <> struct is_proto_enum< ::KeyEncodingType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KeyEncodingType>() {
  return ::KeyEncodingType_descriptor();
}
template <> struct is_proto_enum< ::ImageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ImageType>() {
  return ::ImageType_descriptor();
}
template <> struct is_proto_enum< ::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
