// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class AsymmetriclyEncryptedMessage;
class HybridEncryptedMessage;
class MessageReference;
class Post;
class PrivateKey;
class PublicKey;
class Signature;
class SignedMessage;
class SymmetriclyEncryptedMessage;

enum SignatureType {
  SHA512withECDSA = 0,
  SignatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SignatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SignatureType_IsValid(int value);
const SignatureType SignatureType_MIN = SHA512withECDSA;
const SignatureType SignatureType_MAX = SHA512withECDSA;
const int SignatureType_ARRAYSIZE = SignatureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignatureType_descriptor();
inline const ::std::string& SignatureType_Name(SignatureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignatureType_descriptor(), value);
}
inline bool SignatureType_Parse(
    const ::std::string& name, SignatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignatureType>(
    SignatureType_descriptor(), name, value);
}
enum ECCKeyType {
  secp384r1 = 0,
  ECCKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ECCKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ECCKeyType_IsValid(int value);
const ECCKeyType ECCKeyType_MIN = secp384r1;
const ECCKeyType ECCKeyType_MAX = secp384r1;
const int ECCKeyType_ARRAYSIZE = ECCKeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECCKeyType_descriptor();
inline const ::std::string& ECCKeyType_Name(ECCKeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECCKeyType_descriptor(), value);
}
inline bool ECCKeyType_Parse(
    const ::std::string& name, ECCKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECCKeyType>(
    ECCKeyType_descriptor(), name, value);
}
enum EncryptionType {
  AES_256_GCM_PBKDF2WithHmacSHA256_65536_128 = 0,
  EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EncryptionType_IsValid(int value);
const EncryptionType EncryptionType_MIN = AES_256_GCM_PBKDF2WithHmacSHA256_65536_128;
const EncryptionType EncryptionType_MAX = AES_256_GCM_PBKDF2WithHmacSHA256_65536_128;
const int EncryptionType_ARRAYSIZE = EncryptionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncryptionType_descriptor();
inline const ::std::string& EncryptionType_Name(EncryptionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncryptionType_descriptor(), value);
}
inline bool EncryptionType_Parse(
    const ::std::string& name, EncryptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncryptionType>(
    EncryptionType_descriptor(), name, value);
}
enum KeyEncodingType {
  pkcs8 = 0,
  x509 = 1,
  KeyEncodingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KeyEncodingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KeyEncodingType_IsValid(int value);
const KeyEncodingType KeyEncodingType_MIN = pkcs8;
const KeyEncodingType KeyEncodingType_MAX = x509;
const int KeyEncodingType_ARRAYSIZE = KeyEncodingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEncodingType_descriptor();
inline const ::std::string& KeyEncodingType_Name(KeyEncodingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEncodingType_descriptor(), value);
}
inline bool KeyEncodingType_Parse(
    const ::std::string& name, KeyEncodingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEncodingType>(
    KeyEncodingType_descriptor(), name, value);
}
enum MessageType {
  MessagePost = 0,
  MessageSignature = 1,
  MessagePrivateKey = 2,
  MessagePublicKey = 3,
  MessageSymmetriclyEncryptedMessage = 4,
  MessageAsymmetriclyEncryptedMessage = 5,
  MessageHybridEncryptedMessage = 6,
  MessageReferenceMessage = 7,
  MessageSymetricKey = 100,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MessagePost;
const MessageType MessageType_MAX = MessageSymetricKey;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Post : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Post) */ {
 public:
  Post();
  virtual ~Post();

  Post(const Post& from);

  inline Post& operator=(const Post& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Post& default_instance();

  void Swap(Post* other);

  // implements Message ----------------------------------------------

  inline Post* New() const { return New(NULL); }

  Post* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Post& from);
  void MergeFrom(const Post& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Post* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string location = 4;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional fixed64 start_time = 5;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 5;
  ::google::protobuf::uint64 start_time() const;
  void set_start_time(::google::protobuf::uint64 value);

  // optional bool all_day = 6;
  void clear_all_day();
  static const int kAllDayFieldNumber = 6;
  bool all_day() const;
  void set_all_day(bool value);

  // optional fixed64 end_time = 7;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 7;
  ::google::protobuf::uint64 end_time() const;
  void set_end_time(::google::protobuf::uint64 value);

  // optional bytes image = 8;
  void clear_image();
  static const int kImageFieldNumber = 8;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // optional fixed64 rsvp_by = 9;
  void clear_rsvp_by();
  static const int kRsvpByFieldNumber = 9;
  ::google::protobuf::uint64 rsvp_by() const;
  void set_rsvp_by(::google::protobuf::uint64 value);

  // optional string rsvp_email = 10;
  void clear_rsvp_email();
  static const int kRsvpEmailFieldNumber = 10;
  const ::std::string& rsvp_email() const;
  void set_rsvp_email(const ::std::string& value);
  void set_rsvp_email(const char* value);
  void set_rsvp_email(const char* value, size_t size);
  ::std::string* mutable_rsvp_email();
  ::std::string* release_rsvp_email();
  void set_allocated_rsvp_email(::std::string* rsvp_email);

  // @@protoc_insertion_point(class_scope:Post)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::uint64 start_time_;
  ::google::protobuf::uint64 end_time_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::uint64 rsvp_by_;
  ::google::protobuf::internal::ArenaStringPtr rsvp_email_;
  bool all_day_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Post* default_instance_;
};
// -------------------------------------------------------------------

class Signature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Signature) */ {
 public:
  Signature();
  virtual ~Signature();

  Signature(const Signature& from);

  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signature& default_instance();

  void Swap(Signature* other);

  // implements Message ----------------------------------------------

  inline Signature* New() const { return New(NULL); }

  Signature* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signature& from);
  void MergeFrom(const Signature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional .SignatureType signature_type = 3;
  void clear_signature_type();
  static const int kSignatureTypeFieldNumber = 3;
  ::SignatureType signature_type() const;
  void set_signature_type(::SignatureType value);

  // optional bytes fingerprint = 4;
  void clear_fingerprint();
  static const int kFingerprintFieldNumber = 4;
  const ::std::string& fingerprint() const;
  void set_fingerprint(const ::std::string& value);
  void set_fingerprint(const char* value);
  void set_fingerprint(const void* value, size_t size);
  ::std::string* mutable_fingerprint();
  ::std::string* release_fingerprint();
  void set_allocated_fingerprint(::std::string* fingerprint);

  // optional .MessageReference ref = 5;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 5;
  const ::MessageReference& ref() const;
  ::MessageReference* mutable_ref();
  ::MessageReference* release_ref();
  void set_allocated_ref(::MessageReference* ref);

  // @@protoc_insertion_point(class_scope:Signature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr fingerprint_;
  ::MessageReference* ref_;
  int signature_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Signature* default_instance_;
};
// -------------------------------------------------------------------

class PrivateKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PrivateKey) */ {
 public:
  PrivateKey();
  virtual ~PrivateKey();

  PrivateKey(const PrivateKey& from);

  inline PrivateKey& operator=(const PrivateKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateKey& default_instance();

  void Swap(PrivateKey* other);

  // implements Message ----------------------------------------------

  inline PrivateKey* New() const { return New(NULL); }

  PrivateKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivateKey& from);
  void MergeFrom(const PrivateKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SymmetriclyEncryptedMessage key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::SymmetriclyEncryptedMessage& key() const;
  ::SymmetriclyEncryptedMessage* mutable_key();
  ::SymmetriclyEncryptedMessage* release_key();
  void set_allocated_key(::SymmetriclyEncryptedMessage* key);

  // optional .ECCKeyType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::ECCKeyType type() const;
  void set_type(::ECCKeyType value);

  // optional .KeyEncodingType encodingType = 5;
  void clear_encodingtype();
  static const int kEncodingTypeFieldNumber = 5;
  ::KeyEncodingType encodingtype() const;
  void set_encodingtype(::KeyEncodingType value);

  // optional string name = 6;
  void clear_name();
  static const int kNameFieldNumber = 6;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string email = 7;
  void clear_email();
  static const int kEmailFieldNumber = 7;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // optional string organization = 8;
  void clear_organization();
  static const int kOrganizationFieldNumber = 8;
  const ::std::string& organization() const;
  void set_organization(const ::std::string& value);
  void set_organization(const char* value);
  void set_organization(const char* value, size_t size);
  ::std::string* mutable_organization();
  ::std::string* release_organization();
  void set_allocated_organization(::std::string* organization);

  // @@protoc_insertion_point(class_scope:PrivateKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::SymmetriclyEncryptedMessage* key_;
  int type_;
  int encodingtype_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr organization_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static PrivateKey* default_instance_;
};
// -------------------------------------------------------------------

class PublicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PublicKey) */ {
 public:
  PublicKey();
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicKey& default_instance();

  void Swap(PublicKey* other);

  // implements Message ----------------------------------------------

  inline PublicKey* New() const { return New(NULL); }

  PublicKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .ECCKeyType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::ECCKeyType type() const;
  void set_type(::ECCKeyType value);

  // optional .KeyEncodingType encodingType = 4;
  void clear_encodingtype();
  static const int kEncodingTypeFieldNumber = 4;
  ::KeyEncodingType encodingtype() const;
  void set_encodingtype(::KeyEncodingType value);

  // optional bytes fingerprint = 5;
  void clear_fingerprint();
  static const int kFingerprintFieldNumber = 5;
  const ::std::string& fingerprint() const;
  void set_fingerprint(const ::std::string& value);
  void set_fingerprint(const char* value);
  void set_fingerprint(const void* value, size_t size);
  ::std::string* mutable_fingerprint();
  ::std::string* release_fingerprint();
  void set_allocated_fingerprint(::std::string* fingerprint);

  // optional .MessageReference ref = 6;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 6;
  const ::MessageReference& ref() const;
  ::MessageReference* mutable_ref();
  ::MessageReference* release_ref();
  void set_allocated_ref(::MessageReference* ref);

  // @@protoc_insertion_point(class_scope:PublicKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  int type_;
  int encodingtype_;
  ::google::protobuf::internal::ArenaStringPtr fingerprint_;
  ::MessageReference* ref_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static PublicKey* default_instance_;
};
// -------------------------------------------------------------------

class SymmetriclyEncryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SymmetriclyEncryptedMessage) */ {
 public:
  SymmetriclyEncryptedMessage();
  virtual ~SymmetriclyEncryptedMessage();

  SymmetriclyEncryptedMessage(const SymmetriclyEncryptedMessage& from);

  inline SymmetriclyEncryptedMessage& operator=(const SymmetriclyEncryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymmetriclyEncryptedMessage& default_instance();

  void Swap(SymmetriclyEncryptedMessage* other);

  // implements Message ----------------------------------------------

  inline SymmetriclyEncryptedMessage* New() const { return New(NULL); }

  SymmetriclyEncryptedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymmetriclyEncryptedMessage& from);
  void MergeFrom(const SymmetriclyEncryptedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SymmetriclyEncryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MessageType message_type = 1;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  ::MessageType message_type() const;
  void set_message_type(::MessageType value);

  // optional .EncryptionType encryption_type = 2;
  void clear_encryption_type();
  static const int kEncryptionTypeFieldNumber = 2;
  ::EncryptionType encryption_type() const;
  void set_encryption_type(::EncryptionType value);

  // optional bytes msg = 3;
  void clear_msg();
  static const int kMsgFieldNumber = 3;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional bytes iv = 4;
  void clear_iv();
  static const int kIvFieldNumber = 4;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional bytes salt = 5;
  void clear_salt();
  static const int kSaltFieldNumber = 5;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // optional .MessageReference ref = 6;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 6;
  const ::MessageReference& ref() const;
  ::MessageReference* mutable_ref();
  ::MessageReference* release_ref();
  void set_allocated_ref(::MessageReference* ref);

  // @@protoc_insertion_point(class_scope:SymmetriclyEncryptedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int message_type_;
  int encryption_type_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::MessageReference* ref_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SymmetriclyEncryptedMessage* default_instance_;
};
// -------------------------------------------------------------------

class AsymmetriclyEncryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AsymmetriclyEncryptedMessage) */ {
 public:
  AsymmetriclyEncryptedMessage();
  virtual ~AsymmetriclyEncryptedMessage();

  AsymmetriclyEncryptedMessage(const AsymmetriclyEncryptedMessage& from);

  inline AsymmetriclyEncryptedMessage& operator=(const AsymmetriclyEncryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AsymmetriclyEncryptedMessage& default_instance();

  void Swap(AsymmetriclyEncryptedMessage* other);

  // implements Message ----------------------------------------------

  inline AsymmetriclyEncryptedMessage* New() const { return New(NULL); }

  AsymmetriclyEncryptedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AsymmetriclyEncryptedMessage& from);
  void MergeFrom(const AsymmetriclyEncryptedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AsymmetriclyEncryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MessageType message_type = 1;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  ::MessageType message_type() const;
  void set_message_type(::MessageType value);

  // optional string dest_cn = 2;
  void clear_dest_cn();
  static const int kDestCnFieldNumber = 2;
  const ::std::string& dest_cn() const;
  void set_dest_cn(const ::std::string& value);
  void set_dest_cn(const char* value);
  void set_dest_cn(const char* value, size_t size);
  ::std::string* mutable_dest_cn();
  ::std::string* release_dest_cn();
  void set_allocated_dest_cn(::std::string* dest_cn);

  // optional bytes msg = 4;
  void clear_msg();
  static const int kMsgFieldNumber = 4;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional .MessageReference ref = 5;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 5;
  const ::MessageReference& ref() const;
  ::MessageReference* mutable_ref();
  ::MessageReference* release_ref();
  void set_allocated_ref(::MessageReference* ref);

  // @@protoc_insertion_point(class_scope:AsymmetriclyEncryptedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr dest_cn_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::MessageReference* ref_;
  int message_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static AsymmetriclyEncryptedMessage* default_instance_;
};
// -------------------------------------------------------------------

class HybridEncryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HybridEncryptedMessage) */ {
 public:
  HybridEncryptedMessage();
  virtual ~HybridEncryptedMessage();

  HybridEncryptedMessage(const HybridEncryptedMessage& from);

  inline HybridEncryptedMessage& operator=(const HybridEncryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HybridEncryptedMessage& default_instance();

  void Swap(HybridEncryptedMessage* other);

  // implements Message ----------------------------------------------

  inline HybridEncryptedMessage* New() const { return New(NULL); }

  HybridEncryptedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HybridEncryptedMessage& from);
  void MergeFrom(const HybridEncryptedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HybridEncryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AsymmetriclyEncryptedMessage key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::AsymmetriclyEncryptedMessage& key() const;
  ::AsymmetriclyEncryptedMessage* mutable_key();
  ::AsymmetriclyEncryptedMessage* release_key();
  void set_allocated_key(::AsymmetriclyEncryptedMessage* key);

  // optional .SymmetriclyEncryptedMessage msg = 2;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::SymmetriclyEncryptedMessage& msg() const;
  ::SymmetriclyEncryptedMessage* mutable_msg();
  ::SymmetriclyEncryptedMessage* release_msg();
  void set_allocated_msg(::SymmetriclyEncryptedMessage* msg);

  // optional .MessageReference ref = 3;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 3;
  const ::MessageReference& ref() const;
  ::MessageReference* mutable_ref();
  ::MessageReference* release_ref();
  void set_allocated_ref(::MessageReference* ref);

  // @@protoc_insertion_point(class_scope:HybridEncryptedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::AsymmetriclyEncryptedMessage* key_;
  ::SymmetriclyEncryptedMessage* msg_;
  ::MessageReference* ref_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static HybridEncryptedMessage* default_instance_;
};
// -------------------------------------------------------------------

class MessageReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageReference) */ {
 public:
  MessageReference();
  virtual ~MessageReference();

  MessageReference(const MessageReference& from);

  inline MessageReference& operator=(const MessageReference& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageReference& default_instance();

  void Swap(MessageReference* other);

  // implements Message ----------------------------------------------

  inline MessageReference* New() const { return New(NULL); }

  MessageReference* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageReference& from);
  void MergeFrom(const MessageReference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:MessageReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageReference* default_instance_;
};
// -------------------------------------------------------------------

class SignedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignedMessage) */ {
 public:
  SignedMessage();
  virtual ~SignedMessage();

  SignedMessage(const SignedMessage& from);

  inline SignedMessage& operator=(const SignedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedMessage& default_instance();

  enum MsgCase {
    kPost = 1,
    kSignedMessage = 2,
    kPrivateKey = 3,
    kPublicKey = 4,
    kSymmetriclyEncryptedMessage = 5,
    kAsymmetriclyEncryptedMessage = 6,
    kHybridEncryptedMessage = 7,
    kReference = 10,
    MSG_NOT_SET = 0,
  };

  void Swap(SignedMessage* other);

  // implements Message ----------------------------------------------

  inline SignedMessage* New() const { return New(NULL); }

  SignedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedMessage& from);
  void MergeFrom(const SignedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Post post = 1;
  bool has_post() const;
  void clear_post();
  static const int kPostFieldNumber = 1;
  const ::Post& post() const;
  ::Post* mutable_post();
  ::Post* release_post();
  void set_allocated_post(::Post* post);

  // optional .Signature signedMessage = 2;
  bool has_signedmessage() const;
  void clear_signedmessage();
  static const int kSignedMessageFieldNumber = 2;
  const ::Signature& signedmessage() const;
  ::Signature* mutable_signedmessage();
  ::Signature* release_signedmessage();
  void set_allocated_signedmessage(::Signature* signedmessage);

  // optional .PrivateKey privateKey = 3;
  bool has_privatekey() const;
  void clear_privatekey();
  static const int kPrivateKeyFieldNumber = 3;
  const ::PrivateKey& privatekey() const;
  ::PrivateKey* mutable_privatekey();
  ::PrivateKey* release_privatekey();
  void set_allocated_privatekey(::PrivateKey* privatekey);

  // optional .PublicKey publicKey = 4;
  bool has_publickey() const;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 4;
  const ::PublicKey& publickey() const;
  ::PublicKey* mutable_publickey();
  ::PublicKey* release_publickey();
  void set_allocated_publickey(::PublicKey* publickey);

  // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
  bool has_symmetriclyencryptedmessage() const;
  void clear_symmetriclyencryptedmessage();
  static const int kSymmetriclyEncryptedMessageFieldNumber = 5;
  const ::SymmetriclyEncryptedMessage& symmetriclyencryptedmessage() const;
  ::SymmetriclyEncryptedMessage* mutable_symmetriclyencryptedmessage();
  ::SymmetriclyEncryptedMessage* release_symmetriclyencryptedmessage();
  void set_allocated_symmetriclyencryptedmessage(::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage);

  // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
  bool has_asymmetriclyencryptedmessage() const;
  void clear_asymmetriclyencryptedmessage();
  static const int kAsymmetriclyEncryptedMessageFieldNumber = 6;
  const ::AsymmetriclyEncryptedMessage& asymmetriclyencryptedmessage() const;
  ::AsymmetriclyEncryptedMessage* mutable_asymmetriclyencryptedmessage();
  ::AsymmetriclyEncryptedMessage* release_asymmetriclyencryptedmessage();
  void set_allocated_asymmetriclyencryptedmessage(::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage);

  // optional .HybridEncryptedMessage hybridEncryptedMessage = 7;
  bool has_hybridencryptedmessage() const;
  void clear_hybridencryptedmessage();
  static const int kHybridEncryptedMessageFieldNumber = 7;
  const ::HybridEncryptedMessage& hybridencryptedmessage() const;
  ::HybridEncryptedMessage* mutable_hybridencryptedmessage();
  ::HybridEncryptedMessage* release_hybridencryptedmessage();
  void set_allocated_hybridencryptedmessage(::HybridEncryptedMessage* hybridencryptedmessage);

  // optional .MessageReference reference = 10;
  bool has_reference() const;
  void clear_reference();
  static const int kReferenceFieldNumber = 10;
  const ::MessageReference& reference() const;
  ::MessageReference* mutable_reference();
  ::MessageReference* release_reference();
  void set_allocated_reference(::MessageReference* reference);

  // optional .Signature message_signature = 8;
  bool has_message_signature() const;
  void clear_message_signature();
  static const int kMessageSignatureFieldNumber = 8;
  const ::Signature& message_signature() const;
  ::Signature* mutable_message_signature();
  ::Signature* release_message_signature();
  void set_allocated_message_signature(::Signature* message_signature);

  // optional fixed64 timestamp = 9;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:SignedMessage)
 private:
  inline void set_has_post();
  inline void set_has_signedmessage();
  inline void set_has_privatekey();
  inline void set_has_publickey();
  inline void set_has_symmetriclyencryptedmessage();
  inline void set_has_asymmetriclyencryptedmessage();
  inline void set_has_hybridencryptedmessage();
  inline void set_has_reference();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Signature* message_signature_;
  ::google::protobuf::uint64 timestamp_;
  union MsgUnion {
    MsgUnion() {}
    ::Post* post_;
    ::Signature* signedmessage_;
    ::PrivateKey* privatekey_;
    ::PublicKey* publickey_;
    ::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage_;
    ::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage_;
    ::HybridEncryptedMessage* hybridencryptedmessage_;
    ::MessageReference* reference_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SignedMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Post

// optional string id = 1;
inline void Post::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::id() const {
  // @@protoc_insertion_point(field_get:Post.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.id)
}
inline void Post::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.id)
}
inline void Post::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.id)
}
inline ::std::string* Post::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:Post.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_id() {
  // @@protoc_insertion_point(field_release:Post.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Post.id)
}

// optional string title = 2;
inline void Post::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::title() const {
  // @@protoc_insertion_point(field_get:Post.title)
  return title_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.title)
}
inline void Post::set_title(const char* value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.title)
}
inline void Post::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.title)
}
inline ::std::string* Post::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:Post.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_title() {
  // @@protoc_insertion_point(field_release:Post.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:Post.title)
}

// optional string description = 3;
inline void Post::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::description() const {
  // @@protoc_insertion_point(field_get:Post.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.description)
}
inline void Post::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.description)
}
inline void Post::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.description)
}
inline ::std::string* Post::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:Post.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_description() {
  // @@protoc_insertion_point(field_release:Post.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:Post.description)
}

// optional string location = 4;
inline void Post::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::location() const {
  // @@protoc_insertion_point(field_get:Post.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.location)
}
inline void Post::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.location)
}
inline void Post::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.location)
}
inline ::std::string* Post::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Post.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_location() {
  // @@protoc_insertion_point(field_release:Post.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Post.location)
}

// optional fixed64 start_time = 5;
inline void Post::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Post::start_time() const {
  // @@protoc_insertion_point(field_get:Post.start_time)
  return start_time_;
}
inline void Post::set_start_time(::google::protobuf::uint64 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:Post.start_time)
}

// optional bool all_day = 6;
inline void Post::clear_all_day() {
  all_day_ = false;
}
inline bool Post::all_day() const {
  // @@protoc_insertion_point(field_get:Post.all_day)
  return all_day_;
}
inline void Post::set_all_day(bool value) {
  
  all_day_ = value;
  // @@protoc_insertion_point(field_set:Post.all_day)
}

// optional fixed64 end_time = 7;
inline void Post::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Post::end_time() const {
  // @@protoc_insertion_point(field_get:Post.end_time)
  return end_time_;
}
inline void Post::set_end_time(::google::protobuf::uint64 value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:Post.end_time)
}

// optional bytes image = 8;
inline void Post::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::image() const {
  // @@protoc_insertion_point(field_get:Post.image)
  return image_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.image)
}
inline void Post::set_image(const char* value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.image)
}
inline void Post::set_image(const void* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.image)
}
inline ::std::string* Post::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:Post.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_image() {
  // @@protoc_insertion_point(field_release:Post.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:Post.image)
}

// optional fixed64 rsvp_by = 9;
inline void Post::clear_rsvp_by() {
  rsvp_by_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Post::rsvp_by() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_by)
  return rsvp_by_;
}
inline void Post::set_rsvp_by(::google::protobuf::uint64 value) {
  
  rsvp_by_ = value;
  // @@protoc_insertion_point(field_set:Post.rsvp_by)
}

// optional string rsvp_email = 10;
inline void Post::clear_rsvp_email() {
  rsvp_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Post::rsvp_email() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_email)
  return rsvp_email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_rsvp_email(const ::std::string& value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.rsvp_email)
}
inline void Post::set_rsvp_email(const char* value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.rsvp_email)
}
inline void Post::set_rsvp_email(const char* value, size_t size) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.rsvp_email)
}
inline ::std::string* Post::mutable_rsvp_email() {
  
  // @@protoc_insertion_point(field_mutable:Post.rsvp_email)
  return rsvp_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Post::release_rsvp_email() {
  // @@protoc_insertion_point(field_release:Post.rsvp_email)
  
  return rsvp_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Post::set_allocated_rsvp_email(::std::string* rsvp_email) {
  if (rsvp_email != NULL) {
    
  } else {
    
  }
  rsvp_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rsvp_email);
  // @@protoc_insertion_point(field_set_allocated:Post.rsvp_email)
}

// -------------------------------------------------------------------

// Signature

// optional bytes signature = 2;
inline void Signature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signature::signature() const {
  // @@protoc_insertion_point(field_get:Signature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.signature)
}
inline void Signature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.signature)
}
inline void Signature::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.signature)
}
inline ::std::string* Signature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Signature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signature::release_signature() {
  // @@protoc_insertion_point(field_release:Signature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Signature.signature)
}

// optional .SignatureType signature_type = 3;
inline void Signature::clear_signature_type() {
  signature_type_ = 0;
}
inline ::SignatureType Signature::signature_type() const {
  // @@protoc_insertion_point(field_get:Signature.signature_type)
  return static_cast< ::SignatureType >(signature_type_);
}
inline void Signature::set_signature_type(::SignatureType value) {
  
  signature_type_ = value;
  // @@protoc_insertion_point(field_set:Signature.signature_type)
}

// optional bytes fingerprint = 4;
inline void Signature::clear_fingerprint() {
  fingerprint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signature::fingerprint() const {
  // @@protoc_insertion_point(field_get:Signature.fingerprint)
  return fingerprint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_fingerprint(const ::std::string& value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.fingerprint)
}
inline void Signature::set_fingerprint(const char* value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.fingerprint)
}
inline void Signature::set_fingerprint(const void* value, size_t size) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.fingerprint)
}
inline ::std::string* Signature::mutable_fingerprint() {
  
  // @@protoc_insertion_point(field_mutable:Signature.fingerprint)
  return fingerprint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signature::release_fingerprint() {
  // @@protoc_insertion_point(field_release:Signature.fingerprint)
  
  return fingerprint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_allocated_fingerprint(::std::string* fingerprint) {
  if (fingerprint != NULL) {
    
  } else {
    
  }
  fingerprint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fingerprint);
  // @@protoc_insertion_point(field_set_allocated:Signature.fingerprint)
}

// optional .MessageReference ref = 5;
inline bool Signature::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
inline void Signature::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
inline const ::MessageReference& Signature::ref() const {
  // @@protoc_insertion_point(field_get:Signature.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
inline ::MessageReference* Signature::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:Signature.ref)
  return ref_;
}
inline ::MessageReference* Signature::release_ref() {
  // @@protoc_insertion_point(field_release:Signature.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void Signature::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Signature.ref)
}

// -------------------------------------------------------------------

// PrivateKey

// optional .SymmetriclyEncryptedMessage key = 2;
inline bool PrivateKey::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void PrivateKey::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::SymmetriclyEncryptedMessage& PrivateKey::key() const {
  // @@protoc_insertion_point(field_get:PrivateKey.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::SymmetriclyEncryptedMessage* PrivateKey::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:PrivateKey.key)
  return key_;
}
inline ::SymmetriclyEncryptedMessage* PrivateKey::release_key() {
  // @@protoc_insertion_point(field_release:PrivateKey.key)
  
  ::SymmetriclyEncryptedMessage* temp = key_;
  key_ = NULL;
  return temp;
}
inline void PrivateKey::set_allocated_key(::SymmetriclyEncryptedMessage* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.key)
}

// optional .ECCKeyType type = 3;
inline void PrivateKey::clear_type() {
  type_ = 0;
}
inline ::ECCKeyType PrivateKey::type() const {
  // @@protoc_insertion_point(field_get:PrivateKey.type)
  return static_cast< ::ECCKeyType >(type_);
}
inline void PrivateKey::set_type(::ECCKeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PrivateKey.type)
}

// optional .KeyEncodingType encodingType = 5;
inline void PrivateKey::clear_encodingtype() {
  encodingtype_ = 0;
}
inline ::KeyEncodingType PrivateKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PrivateKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
inline void PrivateKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PrivateKey.encodingType)
}

// optional string name = 6;
inline void PrivateKey::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateKey::name() const {
  // @@protoc_insertion_point(field_get:PrivateKey.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.name)
}
inline void PrivateKey::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.name)
}
inline void PrivateKey::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.name)
}
inline ::std::string* PrivateKey::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateKey::release_name() {
  // @@protoc_insertion_point(field_release:PrivateKey.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.name)
}

// optional string email = 7;
inline void PrivateKey::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateKey::email() const {
  // @@protoc_insertion_point(field_get:PrivateKey.email)
  return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.email)
}
inline void PrivateKey::set_email(const char* value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.email)
}
inline void PrivateKey::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.email)
}
inline ::std::string* PrivateKey::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateKey::release_email() {
  // @@protoc_insertion_point(field_release:PrivateKey.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.email)
}

// optional string organization = 8;
inline void PrivateKey::clear_organization() {
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateKey::organization() const {
  // @@protoc_insertion_point(field_get:PrivateKey.organization)
  return organization_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_organization(const ::std::string& value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.organization)
}
inline void PrivateKey::set_organization(const char* value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.organization)
}
inline void PrivateKey::set_organization(const char* value, size_t size) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.organization)
}
inline ::std::string* PrivateKey::mutable_organization() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.organization)
  return organization_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateKey::release_organization() {
  // @@protoc_insertion_point(field_release:PrivateKey.organization)
  
  return organization_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKey::set_allocated_organization(::std::string* organization) {
  if (organization != NULL) {
    
  } else {
    
  }
  organization_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organization);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.organization)
}

// -------------------------------------------------------------------

// PublicKey

// optional bytes key = 2;
inline void PublicKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicKey::key() const {
  // @@protoc_insertion_point(field_get:PublicKey.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.key)
}
inline void PublicKey::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.key)
}
inline void PublicKey::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.key)
}
inline ::std::string* PublicKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKey::release_key() {
  // @@protoc_insertion_point(field_release:PublicKey.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.key)
}

// optional .ECCKeyType type = 3;
inline void PublicKey::clear_type() {
  type_ = 0;
}
inline ::ECCKeyType PublicKey::type() const {
  // @@protoc_insertion_point(field_get:PublicKey.type)
  return static_cast< ::ECCKeyType >(type_);
}
inline void PublicKey::set_type(::ECCKeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PublicKey.type)
}

// optional .KeyEncodingType encodingType = 4;
inline void PublicKey::clear_encodingtype() {
  encodingtype_ = 0;
}
inline ::KeyEncodingType PublicKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PublicKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
inline void PublicKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PublicKey.encodingType)
}

// optional bytes fingerprint = 5;
inline void PublicKey::clear_fingerprint() {
  fingerprint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicKey::fingerprint() const {
  // @@protoc_insertion_point(field_get:PublicKey.fingerprint)
  return fingerprint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_fingerprint(const ::std::string& value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.fingerprint)
}
inline void PublicKey::set_fingerprint(const char* value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.fingerprint)
}
inline void PublicKey::set_fingerprint(const void* value, size_t size) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.fingerprint)
}
inline ::std::string* PublicKey::mutable_fingerprint() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.fingerprint)
  return fingerprint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKey::release_fingerprint() {
  // @@protoc_insertion_point(field_release:PublicKey.fingerprint)
  
  return fingerprint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_allocated_fingerprint(::std::string* fingerprint) {
  if (fingerprint != NULL) {
    
  } else {
    
  }
  fingerprint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fingerprint);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.fingerprint)
}

// optional .MessageReference ref = 6;
inline bool PublicKey::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
inline void PublicKey::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
inline const ::MessageReference& PublicKey::ref() const {
  // @@protoc_insertion_point(field_get:PublicKey.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
inline ::MessageReference* PublicKey::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:PublicKey.ref)
  return ref_;
}
inline ::MessageReference* PublicKey::release_ref() {
  // @@protoc_insertion_point(field_release:PublicKey.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void PublicKey::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PublicKey.ref)
}

// -------------------------------------------------------------------

// SymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
inline void SymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
inline ::MessageType SymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
inline void SymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.message_type)
}

// optional .EncryptionType encryption_type = 2;
inline void SymmetriclyEncryptedMessage::clear_encryption_type() {
  encryption_type_ = 0;
}
inline ::EncryptionType SymmetriclyEncryptedMessage::encryption_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.encryption_type)
  return static_cast< ::EncryptionType >(encryption_type_);
}
inline void SymmetriclyEncryptedMessage::set_encryption_type(::EncryptionType value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.encryption_type)
}

// optional bytes msg = 3;
inline void SymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.msg)
}
inline void SymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.msg)
}
inline void SymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.msg)
}
inline ::std::string* SymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.msg)
}

// optional bytes iv = 4;
inline void SymmetriclyEncryptedMessage::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymmetriclyEncryptedMessage::iv() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.iv)
}
inline void SymmetriclyEncryptedMessage::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.iv)
}
inline void SymmetriclyEncryptedMessage::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.iv)
}
inline ::std::string* SymmetriclyEncryptedMessage::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymmetriclyEncryptedMessage::release_iv() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.iv)
}

// optional bytes salt = 5;
inline void SymmetriclyEncryptedMessage::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymmetriclyEncryptedMessage::salt() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.salt)
  return salt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.salt)
}
inline void SymmetriclyEncryptedMessage::set_salt(const char* value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.salt)
}
inline void SymmetriclyEncryptedMessage::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.salt)
}
inline ::std::string* SymmetriclyEncryptedMessage::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymmetriclyEncryptedMessage::release_salt() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymmetriclyEncryptedMessage::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.salt)
}

// optional .MessageReference ref = 6;
inline bool SymmetriclyEncryptedMessage::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
inline void SymmetriclyEncryptedMessage::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
inline const ::MessageReference& SymmetriclyEncryptedMessage::ref() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
inline ::MessageReference* SymmetriclyEncryptedMessage::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.ref)
  return ref_;
}
inline ::MessageReference* SymmetriclyEncryptedMessage::release_ref() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void SymmetriclyEncryptedMessage::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.ref)
}

// -------------------------------------------------------------------

// AsymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
inline void AsymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
inline ::MessageType AsymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
inline void AsymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.message_type)
}

// optional string dest_cn = 2;
inline void AsymmetriclyEncryptedMessage::clear_dest_cn() {
  dest_cn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsymmetriclyEncryptedMessage::dest_cn() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.dest_cn)
  return dest_cn_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_dest_cn(const ::std::string& value) {
  
  dest_cn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.dest_cn)
}
inline void AsymmetriclyEncryptedMessage::set_dest_cn(const char* value) {
  
  dest_cn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.dest_cn)
}
inline void AsymmetriclyEncryptedMessage::set_dest_cn(const char* value, size_t size) {
  
  dest_cn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.dest_cn)
}
inline ::std::string* AsymmetriclyEncryptedMessage::mutable_dest_cn() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.dest_cn)
  return dest_cn_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsymmetriclyEncryptedMessage::release_dest_cn() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.dest_cn)
  
  return dest_cn_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_allocated_dest_cn(::std::string* dest_cn) {
  if (dest_cn != NULL) {
    
  } else {
    
  }
  dest_cn_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_cn);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.dest_cn)
}

// optional bytes msg = 4;
inline void AsymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.msg)
}
inline void AsymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.msg)
}
inline void AsymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.msg)
}
inline ::std::string* AsymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.msg)
}

// optional .MessageReference ref = 5;
inline bool AsymmetriclyEncryptedMessage::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
inline void AsymmetriclyEncryptedMessage::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
inline const ::MessageReference& AsymmetriclyEncryptedMessage::ref() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
inline ::MessageReference* AsymmetriclyEncryptedMessage::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.ref)
  return ref_;
}
inline ::MessageReference* AsymmetriclyEncryptedMessage::release_ref() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void AsymmetriclyEncryptedMessage::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.ref)
}

// -------------------------------------------------------------------

// HybridEncryptedMessage

// optional .AsymmetriclyEncryptedMessage key = 1;
inline bool HybridEncryptedMessage::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HybridEncryptedMessage::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::AsymmetriclyEncryptedMessage& HybridEncryptedMessage::key() const {
  // @@protoc_insertion_point(field_get:HybridEncryptedMessage.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::AsymmetriclyEncryptedMessage* HybridEncryptedMessage::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::AsymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:HybridEncryptedMessage.key)
  return key_;
}
inline ::AsymmetriclyEncryptedMessage* HybridEncryptedMessage::release_key() {
  // @@protoc_insertion_point(field_release:HybridEncryptedMessage.key)
  
  ::AsymmetriclyEncryptedMessage* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HybridEncryptedMessage::set_allocated_key(::AsymmetriclyEncryptedMessage* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:HybridEncryptedMessage.key)
}

// optional .SymmetriclyEncryptedMessage msg = 2;
inline bool HybridEncryptedMessage::has_msg() const {
  return !_is_default_instance_ && msg_ != NULL;
}
inline void HybridEncryptedMessage::clear_msg() {
  if (GetArenaNoVirtual() == NULL && msg_ != NULL) delete msg_;
  msg_ = NULL;
}
inline const ::SymmetriclyEncryptedMessage& HybridEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:HybridEncryptedMessage.msg)
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::SymmetriclyEncryptedMessage* HybridEncryptedMessage::mutable_msg() {
  
  if (msg_ == NULL) {
    msg_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:HybridEncryptedMessage.msg)
  return msg_;
}
inline ::SymmetriclyEncryptedMessage* HybridEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:HybridEncryptedMessage.msg)
  
  ::SymmetriclyEncryptedMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void HybridEncryptedMessage::set_allocated_msg(::SymmetriclyEncryptedMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:HybridEncryptedMessage.msg)
}

// optional .MessageReference ref = 3;
inline bool HybridEncryptedMessage::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
inline void HybridEncryptedMessage::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
inline const ::MessageReference& HybridEncryptedMessage::ref() const {
  // @@protoc_insertion_point(field_get:HybridEncryptedMessage.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
inline ::MessageReference* HybridEncryptedMessage::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:HybridEncryptedMessage.ref)
  return ref_;
}
inline ::MessageReference* HybridEncryptedMessage::release_ref() {
  // @@protoc_insertion_point(field_release:HybridEncryptedMessage.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void HybridEncryptedMessage::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:HybridEncryptedMessage.ref)
}

// -------------------------------------------------------------------

// MessageReference

// optional bytes id = 1;
inline void MessageReference::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageReference::id() const {
  // @@protoc_insertion_point(field_get:MessageReference.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageReference::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageReference.id)
}
inline void MessageReference::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageReference.id)
}
inline void MessageReference::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageReference.id)
}
inline ::std::string* MessageReference::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:MessageReference.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageReference::release_id() {
  // @@protoc_insertion_point(field_release:MessageReference.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageReference::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:MessageReference.id)
}

// -------------------------------------------------------------------

// SignedMessage

// optional .Post post = 1;
inline bool SignedMessage::has_post() const {
  return msg_case() == kPost;
}
inline void SignedMessage::set_has_post() {
  _oneof_case_[0] = kPost;
}
inline void SignedMessage::clear_post() {
  if (has_post()) {
    delete msg_.post_;
    clear_has_msg();
  }
}
inline  const ::Post& SignedMessage::post() const {
  // @@protoc_insertion_point(field_get:SignedMessage.post)
  return has_post()
      ? *msg_.post_
      : ::Post::default_instance();
}
inline ::Post* SignedMessage::mutable_post() {
  if (!has_post()) {
    clear_msg();
    set_has_post();
    msg_.post_ = new ::Post;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.post)
  return msg_.post_;
}
inline ::Post* SignedMessage::release_post() {
  // @@protoc_insertion_point(field_release:SignedMessage.post)
  if (has_post()) {
    clear_has_msg();
    ::Post* temp = msg_.post_;
    msg_.post_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_post(::Post* post) {
  clear_msg();
  if (post) {
    set_has_post();
    msg_.post_ = post;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.post)
}

// optional .Signature signedMessage = 2;
inline bool SignedMessage::has_signedmessage() const {
  return msg_case() == kSignedMessage;
}
inline void SignedMessage::set_has_signedmessage() {
  _oneof_case_[0] = kSignedMessage;
}
inline void SignedMessage::clear_signedmessage() {
  if (has_signedmessage()) {
    delete msg_.signedmessage_;
    clear_has_msg();
  }
}
inline  const ::Signature& SignedMessage::signedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.signedMessage)
  return has_signedmessage()
      ? *msg_.signedmessage_
      : ::Signature::default_instance();
}
inline ::Signature* SignedMessage::mutable_signedmessage() {
  if (!has_signedmessage()) {
    clear_msg();
    set_has_signedmessage();
    msg_.signedmessage_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.signedMessage)
  return msg_.signedmessage_;
}
inline ::Signature* SignedMessage::release_signedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.signedMessage)
  if (has_signedmessage()) {
    clear_has_msg();
    ::Signature* temp = msg_.signedmessage_;
    msg_.signedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_signedmessage(::Signature* signedmessage) {
  clear_msg();
  if (signedmessage) {
    set_has_signedmessage();
    msg_.signedmessage_ = signedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.signedMessage)
}

// optional .PrivateKey privateKey = 3;
inline bool SignedMessage::has_privatekey() const {
  return msg_case() == kPrivateKey;
}
inline void SignedMessage::set_has_privatekey() {
  _oneof_case_[0] = kPrivateKey;
}
inline void SignedMessage::clear_privatekey() {
  if (has_privatekey()) {
    delete msg_.privatekey_;
    clear_has_msg();
  }
}
inline  const ::PrivateKey& SignedMessage::privatekey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.privateKey)
  return has_privatekey()
      ? *msg_.privatekey_
      : ::PrivateKey::default_instance();
}
inline ::PrivateKey* SignedMessage::mutable_privatekey() {
  if (!has_privatekey()) {
    clear_msg();
    set_has_privatekey();
    msg_.privatekey_ = new ::PrivateKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.privateKey)
  return msg_.privatekey_;
}
inline ::PrivateKey* SignedMessage::release_privatekey() {
  // @@protoc_insertion_point(field_release:SignedMessage.privateKey)
  if (has_privatekey()) {
    clear_has_msg();
    ::PrivateKey* temp = msg_.privatekey_;
    msg_.privatekey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_privatekey(::PrivateKey* privatekey) {
  clear_msg();
  if (privatekey) {
    set_has_privatekey();
    msg_.privatekey_ = privatekey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.privateKey)
}

// optional .PublicKey publicKey = 4;
inline bool SignedMessage::has_publickey() const {
  return msg_case() == kPublicKey;
}
inline void SignedMessage::set_has_publickey() {
  _oneof_case_[0] = kPublicKey;
}
inline void SignedMessage::clear_publickey() {
  if (has_publickey()) {
    delete msg_.publickey_;
    clear_has_msg();
  }
}
inline  const ::PublicKey& SignedMessage::publickey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.publicKey)
  return has_publickey()
      ? *msg_.publickey_
      : ::PublicKey::default_instance();
}
inline ::PublicKey* SignedMessage::mutable_publickey() {
  if (!has_publickey()) {
    clear_msg();
    set_has_publickey();
    msg_.publickey_ = new ::PublicKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.publicKey)
  return msg_.publickey_;
}
inline ::PublicKey* SignedMessage::release_publickey() {
  // @@protoc_insertion_point(field_release:SignedMessage.publicKey)
  if (has_publickey()) {
    clear_has_msg();
    ::PublicKey* temp = msg_.publickey_;
    msg_.publickey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_publickey(::PublicKey* publickey) {
  clear_msg();
  if (publickey) {
    set_has_publickey();
    msg_.publickey_ = publickey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.publicKey)
}

// optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
inline bool SignedMessage::has_symmetriclyencryptedmessage() const {
  return msg_case() == kSymmetriclyEncryptedMessage;
}
inline void SignedMessage::set_has_symmetriclyencryptedmessage() {
  _oneof_case_[0] = kSymmetriclyEncryptedMessage;
}
inline void SignedMessage::clear_symmetriclyencryptedmessage() {
  if (has_symmetriclyencryptedmessage()) {
    delete msg_.symmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
inline  const ::SymmetriclyEncryptedMessage& SignedMessage::symmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.symmetriclyEncryptedMessage)
  return has_symmetriclyencryptedmessage()
      ? *msg_.symmetriclyencryptedmessage_
      : ::SymmetriclyEncryptedMessage::default_instance();
}
inline ::SymmetriclyEncryptedMessage* SignedMessage::mutable_symmetriclyencryptedmessage() {
  if (!has_symmetriclyencryptedmessage()) {
    clear_msg();
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.symmetriclyEncryptedMessage)
  return msg_.symmetriclyencryptedmessage_;
}
inline ::SymmetriclyEncryptedMessage* SignedMessage::release_symmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.symmetriclyEncryptedMessage)
  if (has_symmetriclyencryptedmessage()) {
    clear_has_msg();
    ::SymmetriclyEncryptedMessage* temp = msg_.symmetriclyencryptedmessage_;
    msg_.symmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_symmetriclyencryptedmessage(::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage) {
  clear_msg();
  if (symmetriclyencryptedmessage) {
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = symmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.symmetriclyEncryptedMessage)
}

// optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
inline bool SignedMessage::has_asymmetriclyencryptedmessage() const {
  return msg_case() == kAsymmetriclyEncryptedMessage;
}
inline void SignedMessage::set_has_asymmetriclyencryptedmessage() {
  _oneof_case_[0] = kAsymmetriclyEncryptedMessage;
}
inline void SignedMessage::clear_asymmetriclyencryptedmessage() {
  if (has_asymmetriclyencryptedmessage()) {
    delete msg_.asymmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
inline  const ::AsymmetriclyEncryptedMessage& SignedMessage::asymmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.asymmetriclyEncryptedMessage)
  return has_asymmetriclyencryptedmessage()
      ? *msg_.asymmetriclyencryptedmessage_
      : ::AsymmetriclyEncryptedMessage::default_instance();
}
inline ::AsymmetriclyEncryptedMessage* SignedMessage::mutable_asymmetriclyencryptedmessage() {
  if (!has_asymmetriclyencryptedmessage()) {
    clear_msg();
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = new ::AsymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.asymmetriclyEncryptedMessage)
  return msg_.asymmetriclyencryptedmessage_;
}
inline ::AsymmetriclyEncryptedMessage* SignedMessage::release_asymmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.asymmetriclyEncryptedMessage)
  if (has_asymmetriclyencryptedmessage()) {
    clear_has_msg();
    ::AsymmetriclyEncryptedMessage* temp = msg_.asymmetriclyencryptedmessage_;
    msg_.asymmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_asymmetriclyencryptedmessage(::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage) {
  clear_msg();
  if (asymmetriclyencryptedmessage) {
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = asymmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.asymmetriclyEncryptedMessage)
}

// optional .HybridEncryptedMessage hybridEncryptedMessage = 7;
inline bool SignedMessage::has_hybridencryptedmessage() const {
  return msg_case() == kHybridEncryptedMessage;
}
inline void SignedMessage::set_has_hybridencryptedmessage() {
  _oneof_case_[0] = kHybridEncryptedMessage;
}
inline void SignedMessage::clear_hybridencryptedmessage() {
  if (has_hybridencryptedmessage()) {
    delete msg_.hybridencryptedmessage_;
    clear_has_msg();
  }
}
inline  const ::HybridEncryptedMessage& SignedMessage::hybridencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.hybridEncryptedMessage)
  return has_hybridencryptedmessage()
      ? *msg_.hybridencryptedmessage_
      : ::HybridEncryptedMessage::default_instance();
}
inline ::HybridEncryptedMessage* SignedMessage::mutable_hybridencryptedmessage() {
  if (!has_hybridencryptedmessage()) {
    clear_msg();
    set_has_hybridencryptedmessage();
    msg_.hybridencryptedmessage_ = new ::HybridEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.hybridEncryptedMessage)
  return msg_.hybridencryptedmessage_;
}
inline ::HybridEncryptedMessage* SignedMessage::release_hybridencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.hybridEncryptedMessage)
  if (has_hybridencryptedmessage()) {
    clear_has_msg();
    ::HybridEncryptedMessage* temp = msg_.hybridencryptedmessage_;
    msg_.hybridencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_hybridencryptedmessage(::HybridEncryptedMessage* hybridencryptedmessage) {
  clear_msg();
  if (hybridencryptedmessage) {
    set_has_hybridencryptedmessage();
    msg_.hybridencryptedmessage_ = hybridencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.hybridEncryptedMessage)
}

// optional .MessageReference reference = 10;
inline bool SignedMessage::has_reference() const {
  return msg_case() == kReference;
}
inline void SignedMessage::set_has_reference() {
  _oneof_case_[0] = kReference;
}
inline void SignedMessage::clear_reference() {
  if (has_reference()) {
    delete msg_.reference_;
    clear_has_msg();
  }
}
inline  const ::MessageReference& SignedMessage::reference() const {
  // @@protoc_insertion_point(field_get:SignedMessage.reference)
  return has_reference()
      ? *msg_.reference_
      : ::MessageReference::default_instance();
}
inline ::MessageReference* SignedMessage::mutable_reference() {
  if (!has_reference()) {
    clear_msg();
    set_has_reference();
    msg_.reference_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.reference)
  return msg_.reference_;
}
inline ::MessageReference* SignedMessage::release_reference() {
  // @@protoc_insertion_point(field_release:SignedMessage.reference)
  if (has_reference()) {
    clear_has_msg();
    ::MessageReference* temp = msg_.reference_;
    msg_.reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SignedMessage::set_allocated_reference(::MessageReference* reference) {
  clear_msg();
  if (reference) {
    set_has_reference();
    msg_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.reference)
}

// optional .Signature message_signature = 8;
inline bool SignedMessage::has_message_signature() const {
  return !_is_default_instance_ && message_signature_ != NULL;
}
inline void SignedMessage::clear_message_signature() {
  if (GetArenaNoVirtual() == NULL && message_signature_ != NULL) delete message_signature_;
  message_signature_ = NULL;
}
inline const ::Signature& SignedMessage::message_signature() const {
  // @@protoc_insertion_point(field_get:SignedMessage.message_signature)
  return message_signature_ != NULL ? *message_signature_ : *default_instance_->message_signature_;
}
inline ::Signature* SignedMessage::mutable_message_signature() {
  
  if (message_signature_ == NULL) {
    message_signature_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.message_signature)
  return message_signature_;
}
inline ::Signature* SignedMessage::release_message_signature() {
  // @@protoc_insertion_point(field_release:SignedMessage.message_signature)
  
  ::Signature* temp = message_signature_;
  message_signature_ = NULL;
  return temp;
}
inline void SignedMessage::set_allocated_message_signature(::Signature* message_signature) {
  delete message_signature_;
  message_signature_ = message_signature;
  if (message_signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.message_signature)
}

// optional fixed64 timestamp = 9;
inline void SignedMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SignedMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:SignedMessage.timestamp)
  return timestamp_;
}
inline void SignedMessage::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SignedMessage.timestamp)
}

inline bool SignedMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void SignedMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline SignedMessage::MsgCase SignedMessage::msg_case() const {
  return SignedMessage::MsgCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SignatureType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignatureType>() {
  return ::SignatureType_descriptor();
}
template <> struct is_proto_enum< ::ECCKeyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECCKeyType>() {
  return ::ECCKeyType_descriptor();
}
template <> struct is_proto_enum< ::EncryptionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EncryptionType>() {
  return ::EncryptionType_descriptor();
}
template <> struct is_proto_enum< ::KeyEncodingType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KeyEncodingType>() {
  return ::KeyEncodingType_descriptor();
}
template <> struct is_proto_enum< ::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
