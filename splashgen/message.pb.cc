// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_message_2eproto() {
  delete Image::default_instance_;
  delete Post::default_instance_;
  delete Signature::default_instance_;
  delete DistinguishedName::default_instance_;
  delete KeyId::default_instance_;
  delete PrivateKey::default_instance_;
  delete PublicKey::default_instance_;
  delete SymmetriclyEncryptedMessage::default_instance_;
  delete AsymmetriclyEncryptedMessage::default_instance_;
  delete MessageReference::default_instance_;
  delete SignedMessage::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_message_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_message_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_message_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Image::default_instance_ = new Image();
  Post::default_instance_ = new Post();
  Signature::default_instance_ = new Signature();
  DistinguishedName::default_instance_ = new DistinguishedName();
  KeyId::default_instance_ = new KeyId();
  PrivateKey::default_instance_ = new PrivateKey();
  PublicKey::default_instance_ = new PublicKey();
  SymmetriclyEncryptedMessage::default_instance_ = new SymmetriclyEncryptedMessage();
  AsymmetriclyEncryptedMessage::default_instance_ = new AsymmetriclyEncryptedMessage();
  MessageReference::default_instance_ = new MessageReference();
  SignedMessage::default_instance_ = new SignedMessage();
  Image::default_instance_->InitAsDefaultInstance();
  Post::default_instance_->InitAsDefaultInstance();
  Signature::default_instance_->InitAsDefaultInstance();
  DistinguishedName::default_instance_->InitAsDefaultInstance();
  KeyId::default_instance_->InitAsDefaultInstance();
  PrivateKey::default_instance_->InitAsDefaultInstance();
  PublicKey::default_instance_->InitAsDefaultInstance();
  SymmetriclyEncryptedMessage::default_instance_->InitAsDefaultInstance();
  AsymmetriclyEncryptedMessage::default_instance_->InitAsDefaultInstance();
  MessageReference::default_instance_->InitAsDefaultInstance();
  SignedMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_message_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_message_2eproto_once_);
void protobuf_AddDesc_message_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_message_2eproto_once_,
                 &protobuf_AddDesc_message_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_message_2eproto {
  StaticDescriptorInitializer_message_2eproto() {
    protobuf_AddDesc_message_2eproto();
  }
} static_descriptor_initializer_message_2eproto_;
#endif
bool SignatureType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

bool AsymmetricKeyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool SymmetricKeyType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

bool KeyEncodingType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool ImageType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

bool MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 100:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image::kImageFieldNumber;
const int Image::kImageTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image::Image()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Image)
}

void Image::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Image::Image(const Image& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Image)
}

void Image::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  image_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  imagetype_ = 0;
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:Image)
  SharedDtor();
}

void Image::SharedDtor() {
  image_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Image& Image::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New(::google::protobuf::Arena* arena) const {
  Image* n = new Image;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:Image)
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  imagetype_ = 0;
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes image = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_imageType;
        break;
      }

      // optional .ImageType imageType = 2;
      case 2: {
        if (tag == 16) {
         parse_imageType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_imagetype(static_cast< ::ImageType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Image)
  // optional bytes image = 1;
  if (this->image().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->image(), output);
  }

  // optional .ImageType imageType = 2;
  if (this->imagetype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->imagetype(), output);
  }

  // @@protoc_insertion_point(serialize_end:Image)
}

int Image::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Image)
  int total_size = 0;

  // optional bytes image = 1;
  if (this->image().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->image());
  }

  // optional .ImageType imageType = 2;
  if (this->imagetype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->imagetype());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Image*>(&from));
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.image().size() > 0) {

    image_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.image_);
  }
  if (from.imagetype() != 0) {
    set_imagetype(from.imagetype());
  }
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {

  return true;
}

void Image::Swap(Image* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image::InternalSwap(Image* other) {
  image_.Swap(&other->image_);
  std::swap(imagetype_, other->imagetype_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Image::GetTypeName() const {
  return "Image";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Image

// optional bytes image = 1;
void Image::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Image::image() const {
  // @@protoc_insertion_point(field_get:Image.image)
  return image_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Image.image)
}
 void Image::set_image(const char* value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Image.image)
}
 void Image::set_image(const void* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Image.image)
}
 ::std::string* Image::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:Image.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image::release_image() {
  // @@protoc_insertion_point(field_release:Image.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:Image.image)
}

// optional .ImageType imageType = 2;
void Image::clear_imagetype() {
  imagetype_ = 0;
}
 ::ImageType Image::imagetype() const {
  // @@protoc_insertion_point(field_get:Image.imageType)
  return static_cast< ::ImageType >(imagetype_);
}
 void Image::set_imagetype(::ImageType value) {
  
  imagetype_ = value;
  // @@protoc_insertion_point(field_set:Image.imageType)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Post::kIdFieldNumber;
const int Post::kTitleFieldNumber;
const int Post::kDescriptionFieldNumber;
const int Post::kLocationFieldNumber;
const int Post::kStartTimeFieldNumber;
const int Post::kAllDayFieldNumber;
const int Post::kEndTimeFieldNumber;
const int Post::kImageFieldNumber;
const int Post::kRsvpByFieldNumber;
const int Post::kRsvpEmailFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Post::Post()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Post)
}

void Post::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  image_ = const_cast< ::Image*>(
      ::Image::internal_default_instance());
#else
  image_ = const_cast< ::Image*>(&::Image::default_instance());
#endif
}

Post::Post(const Post& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Post)
}

void Post::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  start_time_ = GOOGLE_ULONGLONG(0);
  all_day_ = false;
  end_time_ = GOOGLE_ULONGLONG(0);
  image_ = NULL;
  rsvp_by_ = GOOGLE_ULONGLONG(0);
  rsvp_email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Post::~Post() {
  // @@protoc_insertion_point(destructor:Post)
  SharedDtor();
}

void Post::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rsvp_email_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete image_;
  }
}

void Post::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Post& Post::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

Post* Post::default_instance_ = NULL;

Post* Post::New(::google::protobuf::Arena* arena) const {
  Post* n = new Post;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Post::Clear() {
// @@protoc_insertion_point(message_clear_start:Post)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Post, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Post*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(start_time_, end_time_);
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  all_day_ = false;
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
  rsvp_by_ = GOOGLE_ULONGLONG(0);
  rsvp_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool Post::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Post)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_title;
        break;
      }

      // optional string title = 2;
      case 2: {
        if (tag == 18) {
         parse_title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->title().data(), this->title().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.title"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_description;
        break;
      }

      // optional string description = 3;
      case 3: {
        if (tag == 26) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.description"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // optional string location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->location().data(), this->location().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.location"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_start_time;
        break;
      }

      // optional fixed64 start_time = 5;
      case 5: {
        if (tag == 41) {
         parse_start_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &start_time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_all_day;
        break;
      }

      // optional bool all_day = 6;
      case 6: {
        if (tag == 48) {
         parse_all_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &all_day_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_end_time;
        break;
      }

      // optional fixed64 end_time = 7;
      case 7: {
        if (tag == 57) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &end_time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_image;
        break;
      }

      // optional .Image image = 8;
      case 8: {
        if (tag == 66) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_rsvp_by;
        break;
      }

      // optional fixed64 rsvp_by = 9;
      case 9: {
        if (tag == 73) {
         parse_rsvp_by:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &rsvp_by_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_rsvp_email;
        break;
      }

      // optional string rsvp_email = 10;
      case 10: {
        if (tag == 82) {
         parse_rsvp_email:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rsvp_email()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->rsvp_email().data(), this->rsvp_email().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.rsvp_email"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Post)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Post)
  return false;
#undef DO_
}

void Post::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Post)
  // optional bytes id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->id(), output);
  }

  // optional string title = 2;
  if (this->title().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.title");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->title(), output);
  }

  // optional string description = 3;
  if (this->description().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.description");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->description(), output);
  }

  // optional string location = 4;
  if (this->location().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.location");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->location(), output);
  }

  // optional fixed64 start_time = 5;
  if (this->start_time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(5, this->start_time(), output);
  }

  // optional bool all_day = 6;
  if (this->all_day() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->all_day(), output);
  }

  // optional fixed64 end_time = 7;
  if (this->end_time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(7, this->end_time(), output);
  }

  // optional .Image image = 8;
  if (this->has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->image_, output);
  }

  // optional fixed64 rsvp_by = 9;
  if (this->rsvp_by() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(9, this->rsvp_by(), output);
  }

  // optional string rsvp_email = 10;
  if (this->rsvp_email().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->rsvp_email().data(), this->rsvp_email().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.rsvp_email");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->rsvp_email(), output);
  }

  // @@protoc_insertion_point(serialize_end:Post)
}

int Post::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Post)
  int total_size = 0;

  // optional bytes id = 1;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  // optional string title = 2;
  if (this->title().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->title());
  }

  // optional string description = 3;
  if (this->description().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->description());
  }

  // optional string location = 4;
  if (this->location().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->location());
  }

  // optional fixed64 start_time = 5;
  if (this->start_time() != 0) {
    total_size += 1 + 8;
  }

  // optional bool all_day = 6;
  if (this->all_day() != 0) {
    total_size += 1 + 1;
  }

  // optional fixed64 end_time = 7;
  if (this->end_time() != 0) {
    total_size += 1 + 8;
  }

  // optional .Image image = 8;
  if (this->has_image()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->image_);
  }

  // optional fixed64 rsvp_by = 9;
  if (this->rsvp_by() != 0) {
    total_size += 1 + 8;
  }

  // optional string rsvp_email = 10;
  if (this->rsvp_email().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->rsvp_email());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Post::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Post*>(&from));
}

void Post::MergeFrom(const Post& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Post)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  if (from.title().size() > 0) {

    title_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.title_);
  }
  if (from.description().size() > 0) {

    description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  if (from.location().size() > 0) {

    location_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.location_);
  }
  if (from.start_time() != 0) {
    set_start_time(from.start_time());
  }
  if (from.all_day() != 0) {
    set_all_day(from.all_day());
  }
  if (from.end_time() != 0) {
    set_end_time(from.end_time());
  }
  if (from.has_image()) {
    mutable_image()->::Image::MergeFrom(from.image());
  }
  if (from.rsvp_by() != 0) {
    set_rsvp_by(from.rsvp_by());
  }
  if (from.rsvp_email().size() > 0) {

    rsvp_email_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.rsvp_email_);
  }
}

void Post::CopyFrom(const Post& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Post)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Post::IsInitialized() const {

  return true;
}

void Post::Swap(Post* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Post::InternalSwap(Post* other) {
  id_.Swap(&other->id_);
  title_.Swap(&other->title_);
  description_.Swap(&other->description_);
  location_.Swap(&other->location_);
  std::swap(start_time_, other->start_time_);
  std::swap(all_day_, other->all_day_);
  std::swap(end_time_, other->end_time_);
  std::swap(image_, other->image_);
  std::swap(rsvp_by_, other->rsvp_by_);
  rsvp_email_.Swap(&other->rsvp_email_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Post::GetTypeName() const {
  return "Post";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Post

// optional bytes id = 1;
void Post::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::id() const {
  // @@protoc_insertion_point(field_get:Post.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.id)
}
 void Post::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.id)
}
 void Post::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.id)
}
 ::std::string* Post::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:Post.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_id() {
  // @@protoc_insertion_point(field_release:Post.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Post.id)
}

// optional string title = 2;
void Post::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::title() const {
  // @@protoc_insertion_point(field_get:Post.title)
  return title_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.title)
}
 void Post::set_title(const char* value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.title)
}
 void Post::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.title)
}
 ::std::string* Post::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:Post.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_title() {
  // @@protoc_insertion_point(field_release:Post.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:Post.title)
}

// optional string description = 3;
void Post::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::description() const {
  // @@protoc_insertion_point(field_get:Post.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.description)
}
 void Post::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.description)
}
 void Post::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.description)
}
 ::std::string* Post::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:Post.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_description() {
  // @@protoc_insertion_point(field_release:Post.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:Post.description)
}

// optional string location = 4;
void Post::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::location() const {
  // @@protoc_insertion_point(field_get:Post.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.location)
}
 void Post::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.location)
}
 void Post::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.location)
}
 ::std::string* Post::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Post.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_location() {
  // @@protoc_insertion_point(field_release:Post.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Post.location)
}

// optional fixed64 start_time = 5;
void Post::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Post::start_time() const {
  // @@protoc_insertion_point(field_get:Post.start_time)
  return start_time_;
}
 void Post::set_start_time(::google::protobuf::uint64 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:Post.start_time)
}

// optional bool all_day = 6;
void Post::clear_all_day() {
  all_day_ = false;
}
 bool Post::all_day() const {
  // @@protoc_insertion_point(field_get:Post.all_day)
  return all_day_;
}
 void Post::set_all_day(bool value) {
  
  all_day_ = value;
  // @@protoc_insertion_point(field_set:Post.all_day)
}

// optional fixed64 end_time = 7;
void Post::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Post::end_time() const {
  // @@protoc_insertion_point(field_get:Post.end_time)
  return end_time_;
}
 void Post::set_end_time(::google::protobuf::uint64 value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:Post.end_time)
}

// optional .Image image = 8;
bool Post::has_image() const {
  return !_is_default_instance_ && image_ != NULL;
}
void Post::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
const ::Image& Post::image() const {
  // @@protoc_insertion_point(field_get:Post.image)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_ != NULL ? *image_ : *default_instance().image_;
#else
  return image_ != NULL ? *image_ : *default_instance_->image_;
#endif
}
::Image* Post::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::Image;
  }
  // @@protoc_insertion_point(field_mutable:Post.image)
  return image_;
}
::Image* Post::release_image() {
  // @@protoc_insertion_point(field_release:Post.image)
  
  ::Image* temp = image_;
  image_ = NULL;
  return temp;
}
void Post::set_allocated_image(::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Post.image)
}

// optional fixed64 rsvp_by = 9;
void Post::clear_rsvp_by() {
  rsvp_by_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Post::rsvp_by() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_by)
  return rsvp_by_;
}
 void Post::set_rsvp_by(::google::protobuf::uint64 value) {
  
  rsvp_by_ = value;
  // @@protoc_insertion_point(field_set:Post.rsvp_by)
}

// optional string rsvp_email = 10;
void Post::clear_rsvp_email() {
  rsvp_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::rsvp_email() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_email)
  return rsvp_email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_rsvp_email(const ::std::string& value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.rsvp_email)
}
 void Post::set_rsvp_email(const char* value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.rsvp_email)
}
 void Post::set_rsvp_email(const char* value, size_t size) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.rsvp_email)
}
 ::std::string* Post::mutable_rsvp_email() {
  
  // @@protoc_insertion_point(field_mutable:Post.rsvp_email)
  return rsvp_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_rsvp_email() {
  // @@protoc_insertion_point(field_release:Post.rsvp_email)
  
  return rsvp_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_rsvp_email(::std::string* rsvp_email) {
  if (rsvp_email != NULL) {
    
  } else {
    
  }
  rsvp_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rsvp_email);
  // @@protoc_insertion_point(field_set_allocated:Post.rsvp_email)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Signature::kSignatureFieldNumber;
const int Signature::kSignatureTypeFieldNumber;
const int Signature::kIdFieldNumber;
const int Signature::kKeyIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Signature::Signature()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Signature)
}

void Signature::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  key_id_ = const_cast< ::KeyId*>(
      ::KeyId::internal_default_instance());
#else
  key_id_ = const_cast< ::KeyId*>(&::KeyId::default_instance());
#endif
}

Signature::Signature(const Signature& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Signature)
}

void Signature::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_type_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_id_ = NULL;
}

Signature::~Signature() {
  // @@protoc_insertion_point(destructor:Signature)
  SharedDtor();
}

void Signature::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete key_id_;
  }
}

void Signature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Signature& Signature::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

Signature* Signature::default_instance_ = NULL;

Signature* Signature::New(::google::protobuf::Arena* arena) const {
  Signature* n = new Signature;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Signature::Clear() {
// @@protoc_insertion_point(message_clear_start:Signature)
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_type_ = 0;
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
}

bool Signature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Signature)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes signature = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_signature_type;
        break;
      }

      // optional .SignatureType signature_type = 3;
      case 3: {
        if (tag == 24) {
         parse_signature_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_signature_type(static_cast< ::SignatureType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_id;
        break;
      }

      // optional bytes id = 5;
      case 5: {
        if (tag == 42) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_key_id;
        break;
      }

      // optional .KeyId key_id = 6;
      case 6: {
        if (tag == 50) {
         parse_key_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Signature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Signature)
  return false;
#undef DO_
}

void Signature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Signature)
  // optional bytes signature = 2;
  if (this->signature().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional .SignatureType signature_type = 3;
  if (this->signature_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->signature_type(), output);
  }

  // optional bytes id = 5;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->id(), output);
  }

  // optional .KeyId key_id = 6;
  if (this->has_key_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->key_id_, output);
  }

  // @@protoc_insertion_point(serialize_end:Signature)
}

int Signature::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Signature)
  int total_size = 0;

  // optional bytes signature = 2;
  if (this->signature().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  // optional .SignatureType signature_type = 3;
  if (this->signature_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->signature_type());
  }

  // optional bytes id = 5;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  // optional .KeyId key_id = 6;
  if (this->has_key_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->key_id_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Signature::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Signature*>(&from));
}

void Signature::MergeFrom(const Signature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Signature)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.signature().size() > 0) {

    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  if (from.signature_type() != 0) {
    set_signature_type(from.signature_type());
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  if (from.has_key_id()) {
    mutable_key_id()->::KeyId::MergeFrom(from.key_id());
  }
}

void Signature::CopyFrom(const Signature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signature::IsInitialized() const {

  return true;
}

void Signature::Swap(Signature* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Signature::InternalSwap(Signature* other) {
  signature_.Swap(&other->signature_);
  std::swap(signature_type_, other->signature_type_);
  id_.Swap(&other->id_);
  std::swap(key_id_, other->key_id_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Signature::GetTypeName() const {
  return "Signature";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Signature

// optional bytes signature = 2;
void Signature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Signature::signature() const {
  // @@protoc_insertion_point(field_get:Signature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.signature)
}
 void Signature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.signature)
}
 void Signature::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.signature)
}
 ::std::string* Signature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Signature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Signature::release_signature() {
  // @@protoc_insertion_point(field_release:Signature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Signature.signature)
}

// optional .SignatureType signature_type = 3;
void Signature::clear_signature_type() {
  signature_type_ = 0;
}
 ::SignatureType Signature::signature_type() const {
  // @@protoc_insertion_point(field_get:Signature.signature_type)
  return static_cast< ::SignatureType >(signature_type_);
}
 void Signature::set_signature_type(::SignatureType value) {
  
  signature_type_ = value;
  // @@protoc_insertion_point(field_set:Signature.signature_type)
}

// optional bytes id = 5;
void Signature::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Signature::id() const {
  // @@protoc_insertion_point(field_get:Signature.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.id)
}
 void Signature::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.id)
}
 void Signature::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.id)
}
 ::std::string* Signature::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:Signature.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Signature::release_id() {
  // @@protoc_insertion_point(field_release:Signature.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Signature.id)
}

// optional .KeyId key_id = 6;
bool Signature::has_key_id() const {
  return !_is_default_instance_ && key_id_ != NULL;
}
void Signature::clear_key_id() {
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
}
const ::KeyId& Signature::key_id() const {
  // @@protoc_insertion_point(field_get:Signature.key_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_id_ != NULL ? *key_id_ : *default_instance().key_id_;
#else
  return key_id_ != NULL ? *key_id_ : *default_instance_->key_id_;
#endif
}
::KeyId* Signature::mutable_key_id() {
  
  if (key_id_ == NULL) {
    key_id_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:Signature.key_id)
  return key_id_;
}
::KeyId* Signature::release_key_id() {
  // @@protoc_insertion_point(field_release:Signature.key_id)
  
  ::KeyId* temp = key_id_;
  key_id_ = NULL;
  return temp;
}
void Signature::set_allocated_key_id(::KeyId* key_id) {
  delete key_id_;
  key_id_ = key_id;
  if (key_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Signature.key_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DistinguishedName::kCountryFieldNumber;
const int DistinguishedName::kOrganizationFieldNumber;
const int DistinguishedName::kOrganizationalUnitFieldNumber;
const int DistinguishedName::kDistinguishedNameQualifierFieldNumber;
const int DistinguishedName::kStateFieldNumber;
const int DistinguishedName::kCommonNameFieldNumber;
const int DistinguishedName::kSerialNumberFieldNumber;
const int DistinguishedName::kEmailFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DistinguishedName::DistinguishedName()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DistinguishedName)
}

void DistinguishedName::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

DistinguishedName::DistinguishedName(const DistinguishedName& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DistinguishedName)
}

void DistinguishedName::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  country_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organization_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organizational_unit_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  distinguished_name_qualifier_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  common_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serial_number_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

DistinguishedName::~DistinguishedName() {
  // @@protoc_insertion_point(destructor:DistinguishedName)
  SharedDtor();
}

void DistinguishedName::SharedDtor() {
  country_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organization_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organizational_unit_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  distinguished_name_qualifier_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  common_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  email_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DistinguishedName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DistinguishedName& DistinguishedName::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

DistinguishedName* DistinguishedName::default_instance_ = NULL;

DistinguishedName* DistinguishedName::New(::google::protobuf::Arena* arena) const {
  DistinguishedName* n = new DistinguishedName;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DistinguishedName::Clear() {
// @@protoc_insertion_point(message_clear_start:DistinguishedName)
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organizational_unit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  distinguished_name_qualifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  common_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DistinguishedName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DistinguishedName)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string country = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_country()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->country().data(), this->country().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.country"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_organization;
        break;
      }

      // optional string organization = 2;
      case 2: {
        if (tag == 18) {
         parse_organization:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_organization()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->organization().data(), this->organization().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.organization"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_organizational_unit;
        break;
      }

      // optional string organizational_unit = 3;
      case 3: {
        if (tag == 26) {
         parse_organizational_unit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_organizational_unit()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->organizational_unit().data(), this->organizational_unit().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.organizational_unit"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_distinguished_name_qualifier;
        break;
      }

      // optional string distinguished_name_qualifier = 4;
      case 4: {
        if (tag == 34) {
         parse_distinguished_name_qualifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_distinguished_name_qualifier()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->distinguished_name_qualifier().data(), this->distinguished_name_qualifier().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.distinguished_name_qualifier"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_state;
        break;
      }

      // optional string state = 5;
      case 5: {
        if (tag == 42) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->state().data(), this->state().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.state"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_common_name;
        break;
      }

      // optional string common_name = 6;
      case 6: {
        if (tag == 50) {
         parse_common_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_common_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->common_name().data(), this->common_name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.common_name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_serial_number;
        break;
      }

      // optional string serial_number = 7;
      case 7: {
        if (tag == 58) {
         parse_serial_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serial_number()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->serial_number().data(), this->serial_number().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.serial_number"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_email;
        break;
      }

      // optional string email = 8;
      case 8: {
        if (tag == 66) {
         parse_email:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_email()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->email().data(), this->email().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "DistinguishedName.email"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DistinguishedName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DistinguishedName)
  return false;
#undef DO_
}

void DistinguishedName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DistinguishedName)
  // optional string country = 1;
  if (this->country().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->country().data(), this->country().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.country");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->country(), output);
  }

  // optional string organization = 2;
  if (this->organization().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->organization().data(), this->organization().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.organization");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->organization(), output);
  }

  // optional string organizational_unit = 3;
  if (this->organizational_unit().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->organizational_unit().data(), this->organizational_unit().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.organizational_unit");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->organizational_unit(), output);
  }

  // optional string distinguished_name_qualifier = 4;
  if (this->distinguished_name_qualifier().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->distinguished_name_qualifier().data(), this->distinguished_name_qualifier().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.distinguished_name_qualifier");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->distinguished_name_qualifier(), output);
  }

  // optional string state = 5;
  if (this->state().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->state().data(), this->state().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.state");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->state(), output);
  }

  // optional string common_name = 6;
  if (this->common_name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->common_name().data(), this->common_name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.common_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->common_name(), output);
  }

  // optional string serial_number = 7;
  if (this->serial_number().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->serial_number().data(), this->serial_number().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.serial_number");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->serial_number(), output);
  }

  // optional string email = 8;
  if (this->email().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->email().data(), this->email().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "DistinguishedName.email");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->email(), output);
  }

  // @@protoc_insertion_point(serialize_end:DistinguishedName)
}

int DistinguishedName::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DistinguishedName)
  int total_size = 0;

  // optional string country = 1;
  if (this->country().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->country());
  }

  // optional string organization = 2;
  if (this->organization().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->organization());
  }

  // optional string organizational_unit = 3;
  if (this->organizational_unit().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->organizational_unit());
  }

  // optional string distinguished_name_qualifier = 4;
  if (this->distinguished_name_qualifier().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->distinguished_name_qualifier());
  }

  // optional string state = 5;
  if (this->state().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->state());
  }

  // optional string common_name = 6;
  if (this->common_name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->common_name());
  }

  // optional string serial_number = 7;
  if (this->serial_number().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->serial_number());
  }

  // optional string email = 8;
  if (this->email().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->email());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DistinguishedName::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DistinguishedName*>(&from));
}

void DistinguishedName::MergeFrom(const DistinguishedName& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DistinguishedName)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.country().size() > 0) {

    country_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.country_);
  }
  if (from.organization().size() > 0) {

    organization_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.organization_);
  }
  if (from.organizational_unit().size() > 0) {

    organizational_unit_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.organizational_unit_);
  }
  if (from.distinguished_name_qualifier().size() > 0) {

    distinguished_name_qualifier_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.distinguished_name_qualifier_);
  }
  if (from.state().size() > 0) {

    state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.state_);
  }
  if (from.common_name().size() > 0) {

    common_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.common_name_);
  }
  if (from.serial_number().size() > 0) {

    serial_number_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
  }
  if (from.email().size() > 0) {

    email_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.email_);
  }
}

void DistinguishedName::CopyFrom(const DistinguishedName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DistinguishedName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DistinguishedName::IsInitialized() const {

  return true;
}

void DistinguishedName::Swap(DistinguishedName* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DistinguishedName::InternalSwap(DistinguishedName* other) {
  country_.Swap(&other->country_);
  organization_.Swap(&other->organization_);
  organizational_unit_.Swap(&other->organizational_unit_);
  distinguished_name_qualifier_.Swap(&other->distinguished_name_qualifier_);
  state_.Swap(&other->state_);
  common_name_.Swap(&other->common_name_);
  serial_number_.Swap(&other->serial_number_);
  email_.Swap(&other->email_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DistinguishedName::GetTypeName() const {
  return "DistinguishedName";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DistinguishedName

// optional string country = 1;
void DistinguishedName::clear_country() {
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::country() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.country)
  return country_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_country(const ::std::string& value) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.country)
}
 void DistinguishedName::set_country(const char* value) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.country)
}
 void DistinguishedName::set_country(const char* value, size_t size) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.country)
}
 ::std::string* DistinguishedName::mutable_country() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.country)
  return country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_country() {
  // @@protoc_insertion_point(field_release:DistinguishedName.country)
  
  return country_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_country(::std::string* country) {
  if (country != NULL) {
    
  } else {
    
  }
  country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.country)
}

// optional string organization = 2;
void DistinguishedName::clear_organization() {
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::organization() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.organization)
  return organization_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_organization(const ::std::string& value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.organization)
}
 void DistinguishedName::set_organization(const char* value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.organization)
}
 void DistinguishedName::set_organization(const char* value, size_t size) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.organization)
}
 ::std::string* DistinguishedName::mutable_organization() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.organization)
  return organization_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_organization() {
  // @@protoc_insertion_point(field_release:DistinguishedName.organization)
  
  return organization_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_organization(::std::string* organization) {
  if (organization != NULL) {
    
  } else {
    
  }
  organization_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organization);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.organization)
}

// optional string organizational_unit = 3;
void DistinguishedName::clear_organizational_unit() {
  organizational_unit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::organizational_unit() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.organizational_unit)
  return organizational_unit_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_organizational_unit(const ::std::string& value) {
  
  organizational_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.organizational_unit)
}
 void DistinguishedName::set_organizational_unit(const char* value) {
  
  organizational_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.organizational_unit)
}
 void DistinguishedName::set_organizational_unit(const char* value, size_t size) {
  
  organizational_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.organizational_unit)
}
 ::std::string* DistinguishedName::mutable_organizational_unit() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.organizational_unit)
  return organizational_unit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_organizational_unit() {
  // @@protoc_insertion_point(field_release:DistinguishedName.organizational_unit)
  
  return organizational_unit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_organizational_unit(::std::string* organizational_unit) {
  if (organizational_unit != NULL) {
    
  } else {
    
  }
  organizational_unit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organizational_unit);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.organizational_unit)
}

// optional string distinguished_name_qualifier = 4;
void DistinguishedName::clear_distinguished_name_qualifier() {
  distinguished_name_qualifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::distinguished_name_qualifier() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.distinguished_name_qualifier)
  return distinguished_name_qualifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_distinguished_name_qualifier(const ::std::string& value) {
  
  distinguished_name_qualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.distinguished_name_qualifier)
}
 void DistinguishedName::set_distinguished_name_qualifier(const char* value) {
  
  distinguished_name_qualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.distinguished_name_qualifier)
}
 void DistinguishedName::set_distinguished_name_qualifier(const char* value, size_t size) {
  
  distinguished_name_qualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.distinguished_name_qualifier)
}
 ::std::string* DistinguishedName::mutable_distinguished_name_qualifier() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.distinguished_name_qualifier)
  return distinguished_name_qualifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_distinguished_name_qualifier() {
  // @@protoc_insertion_point(field_release:DistinguishedName.distinguished_name_qualifier)
  
  return distinguished_name_qualifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_distinguished_name_qualifier(::std::string* distinguished_name_qualifier) {
  if (distinguished_name_qualifier != NULL) {
    
  } else {
    
  }
  distinguished_name_qualifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), distinguished_name_qualifier);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.distinguished_name_qualifier)
}

// optional string state = 5;
void DistinguishedName::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::state() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.state)
  return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.state)
}
 void DistinguishedName::set_state(const char* value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.state)
}
 void DistinguishedName::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.state)
}
 ::std::string* DistinguishedName::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_state() {
  // @@protoc_insertion_point(field_release:DistinguishedName.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.state)
}

// optional string common_name = 6;
void DistinguishedName::clear_common_name() {
  common_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::common_name() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.common_name)
  return common_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_common_name(const ::std::string& value) {
  
  common_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.common_name)
}
 void DistinguishedName::set_common_name(const char* value) {
  
  common_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.common_name)
}
 void DistinguishedName::set_common_name(const char* value, size_t size) {
  
  common_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.common_name)
}
 ::std::string* DistinguishedName::mutable_common_name() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.common_name)
  return common_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_common_name() {
  // @@protoc_insertion_point(field_release:DistinguishedName.common_name)
  
  return common_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_common_name(::std::string* common_name) {
  if (common_name != NULL) {
    
  } else {
    
  }
  common_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), common_name);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.common_name)
}

// optional string serial_number = 7;
void DistinguishedName::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::serial_number() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.serial_number)
  return serial_number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.serial_number)
}
 void DistinguishedName::set_serial_number(const char* value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.serial_number)
}
 void DistinguishedName::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.serial_number)
}
 ::std::string* DistinguishedName::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_serial_number() {
  // @@protoc_insertion_point(field_release:DistinguishedName.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.serial_number)
}

// optional string email = 8;
void DistinguishedName::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DistinguishedName::email() const {
  // @@protoc_insertion_point(field_get:DistinguishedName.email)
  return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DistinguishedName.email)
}
 void DistinguishedName::set_email(const char* value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DistinguishedName.email)
}
 void DistinguishedName::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DistinguishedName.email)
}
 ::std::string* DistinguishedName::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:DistinguishedName.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DistinguishedName::release_email() {
  // @@protoc_insertion_point(field_release:DistinguishedName.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DistinguishedName::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:DistinguishedName.email)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int KeyId::kFingerprintSha512FieldNumber;
const int KeyId::kDnFieldNumber;
const int KeyId::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

KeyId::KeyId()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:KeyId)
}

void KeyId::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dn_ = const_cast< ::DistinguishedName*>(
      ::DistinguishedName::internal_default_instance());
#else
  dn_ = const_cast< ::DistinguishedName*>(&::DistinguishedName::default_instance());
#endif
}

KeyId::KeyId(const KeyId& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:KeyId)
}

void KeyId::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  fingerprint_sha512_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dn_ = NULL;
  type_ = 0;
}

KeyId::~KeyId() {
  // @@protoc_insertion_point(destructor:KeyId)
  SharedDtor();
}

void KeyId::SharedDtor() {
  fingerprint_sha512_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete dn_;
  }
}

void KeyId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KeyId& KeyId::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

KeyId* KeyId::default_instance_ = NULL;

KeyId* KeyId::New(::google::protobuf::Arena* arena) const {
  KeyId* n = new KeyId;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KeyId::Clear() {
// @@protoc_insertion_point(message_clear_start:KeyId)
  fingerprint_sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && dn_ != NULL) delete dn_;
  dn_ = NULL;
  type_ = 0;
}

bool KeyId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:KeyId)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes fingerprint_sha512 = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fingerprint_sha512()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_dn;
        break;
      }

      // optional .DistinguishedName dn = 2;
      case 2: {
        if (tag == 18) {
         parse_dn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .AsymmetricKeyType type = 3;
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::AsymmetricKeyType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:KeyId)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:KeyId)
  return false;
#undef DO_
}

void KeyId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:KeyId)
  // optional bytes fingerprint_sha512 = 1;
  if (this->fingerprint_sha512().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->fingerprint_sha512(), output);
  }

  // optional .DistinguishedName dn = 2;
  if (this->has_dn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->dn_, output);
  }

  // optional .AsymmetricKeyType type = 3;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // @@protoc_insertion_point(serialize_end:KeyId)
}

int KeyId::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:KeyId)
  int total_size = 0;

  // optional bytes fingerprint_sha512 = 1;
  if (this->fingerprint_sha512().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->fingerprint_sha512());
  }

  // optional .DistinguishedName dn = 2;
  if (this->has_dn()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->dn_);
  }

  // optional .AsymmetricKeyType type = 3;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyId::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KeyId*>(&from));
}

void KeyId::MergeFrom(const KeyId& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:KeyId)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.fingerprint_sha512().size() > 0) {

    fingerprint_sha512_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fingerprint_sha512_);
  }
  if (from.has_dn()) {
    mutable_dn()->::DistinguishedName::MergeFrom(from.dn());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void KeyId::CopyFrom(const KeyId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KeyId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyId::IsInitialized() const {

  return true;
}

void KeyId::Swap(KeyId* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KeyId::InternalSwap(KeyId* other) {
  fingerprint_sha512_.Swap(&other->fingerprint_sha512_);
  std::swap(dn_, other->dn_);
  std::swap(type_, other->type_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string KeyId::GetTypeName() const {
  return "KeyId";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KeyId

// optional bytes fingerprint_sha512 = 1;
void KeyId::clear_fingerprint_sha512() {
  fingerprint_sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& KeyId::fingerprint_sha512() const {
  // @@protoc_insertion_point(field_get:KeyId.fingerprint_sha512)
  return fingerprint_sha512_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void KeyId::set_fingerprint_sha512(const ::std::string& value) {
  
  fingerprint_sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyId.fingerprint_sha512)
}
 void KeyId::set_fingerprint_sha512(const char* value) {
  
  fingerprint_sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyId.fingerprint_sha512)
}
 void KeyId::set_fingerprint_sha512(const void* value, size_t size) {
  
  fingerprint_sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyId.fingerprint_sha512)
}
 ::std::string* KeyId::mutable_fingerprint_sha512() {
  
  // @@protoc_insertion_point(field_mutable:KeyId.fingerprint_sha512)
  return fingerprint_sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* KeyId::release_fingerprint_sha512() {
  // @@protoc_insertion_point(field_release:KeyId.fingerprint_sha512)
  
  return fingerprint_sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void KeyId::set_allocated_fingerprint_sha512(::std::string* fingerprint_sha512) {
  if (fingerprint_sha512 != NULL) {
    
  } else {
    
  }
  fingerprint_sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fingerprint_sha512);
  // @@protoc_insertion_point(field_set_allocated:KeyId.fingerprint_sha512)
}

// optional .DistinguishedName dn = 2;
bool KeyId::has_dn() const {
  return !_is_default_instance_ && dn_ != NULL;
}
void KeyId::clear_dn() {
  if (GetArenaNoVirtual() == NULL && dn_ != NULL) delete dn_;
  dn_ = NULL;
}
const ::DistinguishedName& KeyId::dn() const {
  // @@protoc_insertion_point(field_get:KeyId.dn)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dn_ != NULL ? *dn_ : *default_instance().dn_;
#else
  return dn_ != NULL ? *dn_ : *default_instance_->dn_;
#endif
}
::DistinguishedName* KeyId::mutable_dn() {
  
  if (dn_ == NULL) {
    dn_ = new ::DistinguishedName;
  }
  // @@protoc_insertion_point(field_mutable:KeyId.dn)
  return dn_;
}
::DistinguishedName* KeyId::release_dn() {
  // @@protoc_insertion_point(field_release:KeyId.dn)
  
  ::DistinguishedName* temp = dn_;
  dn_ = NULL;
  return temp;
}
void KeyId::set_allocated_dn(::DistinguishedName* dn) {
  delete dn_;
  dn_ = dn;
  if (dn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:KeyId.dn)
}

// optional .AsymmetricKeyType type = 3;
void KeyId::clear_type() {
  type_ = 0;
}
 ::AsymmetricKeyType KeyId::type() const {
  // @@protoc_insertion_point(field_get:KeyId.type)
  return static_cast< ::AsymmetricKeyType >(type_);
}
 void KeyId::set_type(::AsymmetricKeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:KeyId.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PrivateKey::kKeyFieldNumber;
const int PrivateKey::kEncodingTypeFieldNumber;
const int PrivateKey::kKeyIdFieldNumber;
const int PrivateKey::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PrivateKey::PrivateKey()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PrivateKey)
}

void PrivateKey::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  key_ = const_cast< ::SymmetriclyEncryptedMessage*>(
      ::SymmetriclyEncryptedMessage::internal_default_instance());
#else
  key_ = const_cast< ::SymmetriclyEncryptedMessage*>(&::SymmetriclyEncryptedMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  key_id_ = const_cast< ::KeyId*>(
      ::KeyId::internal_default_instance());
#else
  key_id_ = const_cast< ::KeyId*>(&::KeyId::default_instance());
#endif
}

PrivateKey::PrivateKey(const PrivateKey& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PrivateKey)
}

void PrivateKey::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_ = NULL;
  encodingtype_ = 0;
  key_id_ = NULL;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

PrivateKey::~PrivateKey() {
  // @@protoc_insertion_point(destructor:PrivateKey)
  SharedDtor();
}

void PrivateKey::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete key_;
    delete key_id_;
  }
}

void PrivateKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PrivateKey& PrivateKey::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

PrivateKey* PrivateKey::default_instance_ = NULL;

PrivateKey* PrivateKey::New(::google::protobuf::Arena* arena) const {
  PrivateKey* n = new PrivateKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PrivateKey::Clear() {
// @@protoc_insertion_point(message_clear_start:PrivateKey)
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
  encodingtype_ = 0;
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PrivateKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PrivateKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SymmetriclyEncryptedMessage key = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_encodingType;
        break;
      }

      // optional .KeyEncodingType encodingType = 5;
      case 5: {
        if (tag == 40) {
         parse_encodingType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encodingtype(static_cast< ::KeyEncodingType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_key_id;
        break;
      }

      // optional .KeyId key_id = 6;
      case 6: {
        if (tag == 50) {
         parse_key_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_id;
        break;
      }

      // optional bytes id = 7;
      case 7: {
        if (tag == 58) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PrivateKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PrivateKey)
  return false;
#undef DO_
}

void PrivateKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PrivateKey)
  // optional .SymmetriclyEncryptedMessage key = 2;
  if (this->has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->key_, output);
  }

  // optional .KeyEncodingType encodingType = 5;
  if (this->encodingtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->encodingtype(), output);
  }

  // optional .KeyId key_id = 6;
  if (this->has_key_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->key_id_, output);
  }

  // optional bytes id = 7;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->id(), output);
  }

  // @@protoc_insertion_point(serialize_end:PrivateKey)
}

int PrivateKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:PrivateKey)
  int total_size = 0;

  // optional .SymmetriclyEncryptedMessage key = 2;
  if (this->has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->key_);
  }

  // optional .KeyEncodingType encodingType = 5;
  if (this->encodingtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encodingtype());
  }

  // optional .KeyId key_id = 6;
  if (this->has_key_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->key_id_);
  }

  // optional bytes id = 7;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PrivateKey::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PrivateKey*>(&from));
}

void PrivateKey::MergeFrom(const PrivateKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PrivateKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.has_key()) {
    mutable_key()->::SymmetriclyEncryptedMessage::MergeFrom(from.key());
  }
  if (from.encodingtype() != 0) {
    set_encodingtype(from.encodingtype());
  }
  if (from.has_key_id()) {
    mutable_key_id()->::KeyId::MergeFrom(from.key_id());
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void PrivateKey::CopyFrom(const PrivateKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PrivateKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivateKey::IsInitialized() const {

  return true;
}

void PrivateKey::Swap(PrivateKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PrivateKey::InternalSwap(PrivateKey* other) {
  std::swap(key_, other->key_);
  std::swap(encodingtype_, other->encodingtype_);
  std::swap(key_id_, other->key_id_);
  id_.Swap(&other->id_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PrivateKey::GetTypeName() const {
  return "PrivateKey";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PrivateKey

// optional .SymmetriclyEncryptedMessage key = 2;
bool PrivateKey::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
void PrivateKey::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
const ::SymmetriclyEncryptedMessage& PrivateKey::key() const {
  // @@protoc_insertion_point(field_get:PrivateKey.key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_ != NULL ? *key_ : *default_instance().key_;
#else
  return key_ != NULL ? *key_ : *default_instance_->key_;
#endif
}
::SymmetriclyEncryptedMessage* PrivateKey::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:PrivateKey.key)
  return key_;
}
::SymmetriclyEncryptedMessage* PrivateKey::release_key() {
  // @@protoc_insertion_point(field_release:PrivateKey.key)
  
  ::SymmetriclyEncryptedMessage* temp = key_;
  key_ = NULL;
  return temp;
}
void PrivateKey::set_allocated_key(::SymmetriclyEncryptedMessage* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.key)
}

// optional .KeyEncodingType encodingType = 5;
void PrivateKey::clear_encodingtype() {
  encodingtype_ = 0;
}
 ::KeyEncodingType PrivateKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PrivateKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
 void PrivateKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PrivateKey.encodingType)
}

// optional .KeyId key_id = 6;
bool PrivateKey::has_key_id() const {
  return !_is_default_instance_ && key_id_ != NULL;
}
void PrivateKey::clear_key_id() {
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
}
const ::KeyId& PrivateKey::key_id() const {
  // @@protoc_insertion_point(field_get:PrivateKey.key_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_id_ != NULL ? *key_id_ : *default_instance().key_id_;
#else
  return key_id_ != NULL ? *key_id_ : *default_instance_->key_id_;
#endif
}
::KeyId* PrivateKey::mutable_key_id() {
  
  if (key_id_ == NULL) {
    key_id_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:PrivateKey.key_id)
  return key_id_;
}
::KeyId* PrivateKey::release_key_id() {
  // @@protoc_insertion_point(field_release:PrivateKey.key_id)
  
  ::KeyId* temp = key_id_;
  key_id_ = NULL;
  return temp;
}
void PrivateKey::set_allocated_key_id(::KeyId* key_id) {
  delete key_id_;
  key_id_ = key_id;
  if (key_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.key_id)
}

// optional bytes id = 7;
void PrivateKey::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PrivateKey::id() const {
  // @@protoc_insertion_point(field_get:PrivateKey.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.id)
}
 void PrivateKey::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.id)
}
 void PrivateKey::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.id)
}
 ::std::string* PrivateKey::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PrivateKey::release_id() {
  // @@protoc_insertion_point(field_release:PrivateKey.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PublicKey::kKeyFieldNumber;
const int PublicKey::kEncodingTypeFieldNumber;
const int PublicKey::kKeyIdFieldNumber;
const int PublicKey::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PublicKey::PublicKey()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicKey)
}

void PublicKey::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  key_id_ = const_cast< ::KeyId*>(
      ::KeyId::internal_default_instance());
#else
  key_id_ = const_cast< ::KeyId*>(&::KeyId::default_instance());
#endif
}

PublicKey::PublicKey(const PublicKey& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicKey)
}

void PublicKey::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  encodingtype_ = 0;
  key_id_ = NULL;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

PublicKey::~PublicKey() {
  // @@protoc_insertion_point(destructor:PublicKey)
  SharedDtor();
}

void PublicKey::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete key_id_;
  }
}

void PublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PublicKey& PublicKey::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

PublicKey* PublicKey::default_instance_ = NULL;

PublicKey* PublicKey::New(::google::protobuf::Arena* arena) const {
  PublicKey* n = new PublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:PublicKey)
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  encodingtype_ = 0;
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_encodingType;
        break;
      }

      // optional .KeyEncodingType encodingType = 4;
      case 4: {
        if (tag == 32) {
         parse_encodingType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encodingtype(static_cast< ::KeyEncodingType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_key_id;
        break;
      }

      // optional .KeyId key_id = 5;
      case 5: {
        if (tag == 42) {
         parse_key_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_id;
        break;
      }

      // optional bytes id = 6;
      case 6: {
        if (tag == 50) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicKey)
  return false;
#undef DO_
}

void PublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicKey)
  // optional bytes key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->key(), output);
  }

  // optional .KeyEncodingType encodingType = 4;
  if (this->encodingtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->encodingtype(), output);
  }

  // optional .KeyId key_id = 5;
  if (this->has_key_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->key_id_, output);
  }

  // optional bytes id = 6;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->id(), output);
  }

  // @@protoc_insertion_point(serialize_end:PublicKey)
}

int PublicKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:PublicKey)
  int total_size = 0;

  // optional bytes key = 2;
  if (this->key().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->key());
  }

  // optional .KeyEncodingType encodingType = 4;
  if (this->encodingtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encodingtype());
  }

  // optional .KeyId key_id = 5;
  if (this->has_key_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->key_id_);
  }

  // optional bytes id = 6;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PublicKey::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PublicKey*>(&from));
}

void PublicKey::MergeFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PublicKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.key().size() > 0) {

    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from.encodingtype() != 0) {
    set_encodingtype(from.encodingtype());
  }
  if (from.has_key_id()) {
    mutable_key_id()->::KeyId::MergeFrom(from.key_id());
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void PublicKey::CopyFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {

  return true;
}

void PublicKey::Swap(PublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PublicKey::InternalSwap(PublicKey* other) {
  key_.Swap(&other->key_);
  std::swap(encodingtype_, other->encodingtype_);
  std::swap(key_id_, other->key_id_);
  id_.Swap(&other->id_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PublicKey::GetTypeName() const {
  return "PublicKey";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PublicKey

// optional bytes key = 2;
void PublicKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PublicKey::key() const {
  // @@protoc_insertion_point(field_get:PublicKey.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.key)
}
 void PublicKey::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.key)
}
 void PublicKey::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.key)
}
 ::std::string* PublicKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PublicKey::release_key() {
  // @@protoc_insertion_point(field_release:PublicKey.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.key)
}

// optional .KeyEncodingType encodingType = 4;
void PublicKey::clear_encodingtype() {
  encodingtype_ = 0;
}
 ::KeyEncodingType PublicKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PublicKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
 void PublicKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PublicKey.encodingType)
}

// optional .KeyId key_id = 5;
bool PublicKey::has_key_id() const {
  return !_is_default_instance_ && key_id_ != NULL;
}
void PublicKey::clear_key_id() {
  if (GetArenaNoVirtual() == NULL && key_id_ != NULL) delete key_id_;
  key_id_ = NULL;
}
const ::KeyId& PublicKey::key_id() const {
  // @@protoc_insertion_point(field_get:PublicKey.key_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_id_ != NULL ? *key_id_ : *default_instance().key_id_;
#else
  return key_id_ != NULL ? *key_id_ : *default_instance_->key_id_;
#endif
}
::KeyId* PublicKey::mutable_key_id() {
  
  if (key_id_ == NULL) {
    key_id_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:PublicKey.key_id)
  return key_id_;
}
::KeyId* PublicKey::release_key_id() {
  // @@protoc_insertion_point(field_release:PublicKey.key_id)
  
  ::KeyId* temp = key_id_;
  key_id_ = NULL;
  return temp;
}
void PublicKey::set_allocated_key_id(::KeyId* key_id) {
  delete key_id_;
  key_id_ = key_id;
  if (key_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PublicKey.key_id)
}

// optional bytes id = 6;
void PublicKey::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PublicKey::id() const {
  // @@protoc_insertion_point(field_get:PublicKey.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.id)
}
 void PublicKey::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.id)
}
 void PublicKey::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.id)
}
 ::std::string* PublicKey::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PublicKey::release_id() {
  // @@protoc_insertion_point(field_release:PublicKey.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SymmetriclyEncryptedMessage::kMessageTypeFieldNumber;
const int SymmetriclyEncryptedMessage::kEncryptionTypeFieldNumber;
const int SymmetriclyEncryptedMessage::kMsgFieldNumber;
const int SymmetriclyEncryptedMessage::kIvFieldNumber;
const int SymmetriclyEncryptedMessage::kSaltFieldNumber;
const int SymmetriclyEncryptedMessage::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SymmetriclyEncryptedMessage::SymmetriclyEncryptedMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SymmetriclyEncryptedMessage)
}

void SymmetriclyEncryptedMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

SymmetriclyEncryptedMessage::SymmetriclyEncryptedMessage(const SymmetriclyEncryptedMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SymmetriclyEncryptedMessage)
}

void SymmetriclyEncryptedMessage::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_type_ = 0;
  encryption_type_ = 0;
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  salt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

SymmetriclyEncryptedMessage::~SymmetriclyEncryptedMessage() {
  // @@protoc_insertion_point(destructor:SymmetriclyEncryptedMessage)
  SharedDtor();
}

void SymmetriclyEncryptedMessage::SharedDtor() {
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  salt_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SymmetriclyEncryptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SymmetriclyEncryptedMessage& SymmetriclyEncryptedMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

SymmetriclyEncryptedMessage* SymmetriclyEncryptedMessage::default_instance_ = NULL;

SymmetriclyEncryptedMessage* SymmetriclyEncryptedMessage::New(::google::protobuf::Arena* arena) const {
  SymmetriclyEncryptedMessage* n = new SymmetriclyEncryptedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SymmetriclyEncryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SymmetriclyEncryptedMessage)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SymmetriclyEncryptedMessage, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SymmetriclyEncryptedMessage*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(message_type_, encryption_type_);
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool SymmetriclyEncryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SymmetriclyEncryptedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MessageType message_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_message_type(static_cast< ::MessageType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_encryption_type;
        break;
      }

      // optional .SymmetricKeyType encryption_type = 2;
      case 2: {
        if (tag == 16) {
         parse_encryption_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encryption_type(static_cast< ::SymmetricKeyType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_msg;
        break;
      }

      // optional bytes msg = 3;
      case 3: {
        if (tag == 26) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_iv;
        break;
      }

      // optional bytes iv = 4;
      case 4: {
        if (tag == 34) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_salt;
        break;
      }

      // optional bytes salt = 5;
      case 5: {
        if (tag == 42) {
         parse_salt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_salt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_id;
        break;
      }

      // optional bytes id = 6;
      case 6: {
        if (tag == 50) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SymmetriclyEncryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SymmetriclyEncryptedMessage)
  return false;
#undef DO_
}

void SymmetriclyEncryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SymmetriclyEncryptedMessage)
  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->message_type(), output);
  }

  // optional .SymmetricKeyType encryption_type = 2;
  if (this->encryption_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->encryption_type(), output);
  }

  // optional bytes msg = 3;
  if (this->msg().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->msg(), output);
  }

  // optional bytes iv = 4;
  if (this->iv().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->iv(), output);
  }

  // optional bytes salt = 5;
  if (this->salt().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->salt(), output);
  }

  // optional bytes id = 6;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->id(), output);
  }

  // @@protoc_insertion_point(serialize_end:SymmetriclyEncryptedMessage)
}

int SymmetriclyEncryptedMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:SymmetriclyEncryptedMessage)
  int total_size = 0;

  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
  }

  // optional .SymmetricKeyType encryption_type = 2;
  if (this->encryption_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encryption_type());
  }

  // optional bytes msg = 3;
  if (this->msg().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->msg());
  }

  // optional bytes iv = 4;
  if (this->iv().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->iv());
  }

  // optional bytes salt = 5;
  if (this->salt().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->salt());
  }

  // optional bytes id = 6;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SymmetriclyEncryptedMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SymmetriclyEncryptedMessage*>(&from));
}

void SymmetriclyEncryptedMessage::MergeFrom(const SymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SymmetriclyEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.message_type() != 0) {
    set_message_type(from.message_type());
  }
  if (from.encryption_type() != 0) {
    set_encryption_type(from.encryption_type());
  }
  if (from.msg().size() > 0) {

    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
  if (from.iv().size() > 0) {

    iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
  }
  if (from.salt().size() > 0) {

    salt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.salt_);
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void SymmetriclyEncryptedMessage::CopyFrom(const SymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SymmetriclyEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymmetriclyEncryptedMessage::IsInitialized() const {

  return true;
}

void SymmetriclyEncryptedMessage::Swap(SymmetriclyEncryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SymmetriclyEncryptedMessage::InternalSwap(SymmetriclyEncryptedMessage* other) {
  std::swap(message_type_, other->message_type_);
  std::swap(encryption_type_, other->encryption_type_);
  msg_.Swap(&other->msg_);
  iv_.Swap(&other->iv_);
  salt_.Swap(&other->salt_);
  id_.Swap(&other->id_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SymmetriclyEncryptedMessage::GetTypeName() const {
  return "SymmetriclyEncryptedMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
void SymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
 ::MessageType SymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
 void SymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.message_type)
}

// optional .SymmetricKeyType encryption_type = 2;
void SymmetriclyEncryptedMessage::clear_encryption_type() {
  encryption_type_ = 0;
}
 ::SymmetricKeyType SymmetriclyEncryptedMessage::encryption_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.encryption_type)
  return static_cast< ::SymmetricKeyType >(encryption_type_);
}
 void SymmetriclyEncryptedMessage::set_encryption_type(::SymmetricKeyType value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.encryption_type)
}

// optional bytes msg = 3;
void SymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.msg)
}
 void SymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.msg)
}
 void SymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.msg)
}
 ::std::string* SymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.msg)
}

// optional bytes iv = 4;
void SymmetriclyEncryptedMessage::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SymmetriclyEncryptedMessage::iv() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.iv)
}
 void SymmetriclyEncryptedMessage::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.iv)
}
 void SymmetriclyEncryptedMessage::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.iv)
}
 ::std::string* SymmetriclyEncryptedMessage::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymmetriclyEncryptedMessage::release_iv() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.iv)
}

// optional bytes salt = 5;
void SymmetriclyEncryptedMessage::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SymmetriclyEncryptedMessage::salt() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.salt)
  return salt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.salt)
}
 void SymmetriclyEncryptedMessage::set_salt(const char* value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.salt)
}
 void SymmetriclyEncryptedMessage::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.salt)
}
 ::std::string* SymmetriclyEncryptedMessage::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymmetriclyEncryptedMessage::release_salt() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.salt)
}

// optional bytes id = 6;
void SymmetriclyEncryptedMessage::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SymmetriclyEncryptedMessage::id() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.id)
}
 void SymmetriclyEncryptedMessage::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.id)
}
 void SymmetriclyEncryptedMessage::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.id)
}
 ::std::string* SymmetriclyEncryptedMessage::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymmetriclyEncryptedMessage::release_id() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AsymmetriclyEncryptedMessage::kMessageTypeFieldNumber;
const int AsymmetriclyEncryptedMessage::kDestKeyFieldNumber;
const int AsymmetriclyEncryptedMessage::kMsgFieldNumber;
const int AsymmetriclyEncryptedMessage::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AsymmetriclyEncryptedMessage::AsymmetriclyEncryptedMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AsymmetriclyEncryptedMessage)
}

void AsymmetriclyEncryptedMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dest_key_ = const_cast< ::KeyId*>(
      ::KeyId::internal_default_instance());
#else
  dest_key_ = const_cast< ::KeyId*>(&::KeyId::default_instance());
#endif
}

AsymmetriclyEncryptedMessage::AsymmetriclyEncryptedMessage(const AsymmetriclyEncryptedMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AsymmetriclyEncryptedMessage)
}

void AsymmetriclyEncryptedMessage::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_type_ = 0;
  dest_key_ = NULL;
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

AsymmetriclyEncryptedMessage::~AsymmetriclyEncryptedMessage() {
  // @@protoc_insertion_point(destructor:AsymmetriclyEncryptedMessage)
  SharedDtor();
}

void AsymmetriclyEncryptedMessage::SharedDtor() {
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete dest_key_;
  }
}

void AsymmetriclyEncryptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AsymmetriclyEncryptedMessage& AsymmetriclyEncryptedMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

AsymmetriclyEncryptedMessage* AsymmetriclyEncryptedMessage::default_instance_ = NULL;

AsymmetriclyEncryptedMessage* AsymmetriclyEncryptedMessage::New(::google::protobuf::Arena* arena) const {
  AsymmetriclyEncryptedMessage* n = new AsymmetriclyEncryptedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AsymmetriclyEncryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AsymmetriclyEncryptedMessage)
  message_type_ = 0;
  if (GetArenaNoVirtual() == NULL && dest_key_ != NULL) delete dest_key_;
  dest_key_ = NULL;
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool AsymmetriclyEncryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AsymmetriclyEncryptedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MessageType message_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_message_type(static_cast< ::MessageType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_dest_key;
        break;
      }

      // optional .KeyId dest_key = 2;
      case 2: {
        if (tag == 18) {
         parse_dest_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dest_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_msg;
        break;
      }

      // optional bytes msg = 4;
      case 4: {
        if (tag == 34) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_id;
        break;
      }

      // optional bytes id = 5;
      case 5: {
        if (tag == 42) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AsymmetriclyEncryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AsymmetriclyEncryptedMessage)
  return false;
#undef DO_
}

void AsymmetriclyEncryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AsymmetriclyEncryptedMessage)
  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->message_type(), output);
  }

  // optional .KeyId dest_key = 2;
  if (this->has_dest_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->dest_key_, output);
  }

  // optional bytes msg = 4;
  if (this->msg().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->msg(), output);
  }

  // optional bytes id = 5;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->id(), output);
  }

  // @@protoc_insertion_point(serialize_end:AsymmetriclyEncryptedMessage)
}

int AsymmetriclyEncryptedMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:AsymmetriclyEncryptedMessage)
  int total_size = 0;

  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
  }

  // optional .KeyId dest_key = 2;
  if (this->has_dest_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->dest_key_);
  }

  // optional bytes msg = 4;
  if (this->msg().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->msg());
  }

  // optional bytes id = 5;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AsymmetriclyEncryptedMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AsymmetriclyEncryptedMessage*>(&from));
}

void AsymmetriclyEncryptedMessage::MergeFrom(const AsymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AsymmetriclyEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.message_type() != 0) {
    set_message_type(from.message_type());
  }
  if (from.has_dest_key()) {
    mutable_dest_key()->::KeyId::MergeFrom(from.dest_key());
  }
  if (from.msg().size() > 0) {

    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void AsymmetriclyEncryptedMessage::CopyFrom(const AsymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AsymmetriclyEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymmetriclyEncryptedMessage::IsInitialized() const {

  return true;
}

void AsymmetriclyEncryptedMessage::Swap(AsymmetriclyEncryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AsymmetriclyEncryptedMessage::InternalSwap(AsymmetriclyEncryptedMessage* other) {
  std::swap(message_type_, other->message_type_);
  std::swap(dest_key_, other->dest_key_);
  msg_.Swap(&other->msg_);
  id_.Swap(&other->id_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string AsymmetriclyEncryptedMessage::GetTypeName() const {
  return "AsymmetriclyEncryptedMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AsymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
void AsymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
 ::MessageType AsymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
 void AsymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.message_type)
}

// optional .KeyId dest_key = 2;
bool AsymmetriclyEncryptedMessage::has_dest_key() const {
  return !_is_default_instance_ && dest_key_ != NULL;
}
void AsymmetriclyEncryptedMessage::clear_dest_key() {
  if (GetArenaNoVirtual() == NULL && dest_key_ != NULL) delete dest_key_;
  dest_key_ = NULL;
}
const ::KeyId& AsymmetriclyEncryptedMessage::dest_key() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.dest_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dest_key_ != NULL ? *dest_key_ : *default_instance().dest_key_;
#else
  return dest_key_ != NULL ? *dest_key_ : *default_instance_->dest_key_;
#endif
}
::KeyId* AsymmetriclyEncryptedMessage::mutable_dest_key() {
  
  if (dest_key_ == NULL) {
    dest_key_ = new ::KeyId;
  }
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.dest_key)
  return dest_key_;
}
::KeyId* AsymmetriclyEncryptedMessage::release_dest_key() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.dest_key)
  
  ::KeyId* temp = dest_key_;
  dest_key_ = NULL;
  return temp;
}
void AsymmetriclyEncryptedMessage::set_allocated_dest_key(::KeyId* dest_key) {
  delete dest_key_;
  dest_key_ = dest_key;
  if (dest_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.dest_key)
}

// optional bytes msg = 4;
void AsymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AsymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.msg)
}
 void AsymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.msg)
}
 void AsymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.msg)
}
 ::std::string* AsymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AsymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.msg)
}

// optional bytes id = 5;
void AsymmetriclyEncryptedMessage::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AsymmetriclyEncryptedMessage::id() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.id)
}
 void AsymmetriclyEncryptedMessage::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.id)
}
 void AsymmetriclyEncryptedMessage::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.id)
}
 ::std::string* AsymmetriclyEncryptedMessage::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AsymmetriclyEncryptedMessage::release_id() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MessageReference::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MessageReference::MessageReference()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MessageReference)
}

void MessageReference::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

MessageReference::MessageReference(const MessageReference& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MessageReference)
}

void MessageReference::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

MessageReference::~MessageReference() {
  // @@protoc_insertion_point(destructor:MessageReference)
  SharedDtor();
}

void MessageReference::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MessageReference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MessageReference& MessageReference::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

MessageReference* MessageReference::default_instance_ = NULL;

MessageReference* MessageReference::New(::google::protobuf::Arena* arena) const {
  MessageReference* n = new MessageReference;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MessageReference::Clear() {
// @@protoc_insertion_point(message_clear_start:MessageReference)
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MessageReference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MessageReference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MessageReference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MessageReference)
  return false;
#undef DO_
}

void MessageReference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MessageReference)
  // optional bytes id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->id(), output);
  }

  // @@protoc_insertion_point(serialize_end:MessageReference)
}

int MessageReference::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:MessageReference)
  int total_size = 0;

  // optional bytes id = 1;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MessageReference::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MessageReference*>(&from));
}

void MessageReference::MergeFrom(const MessageReference& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MessageReference)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void MessageReference::CopyFrom(const MessageReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MessageReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageReference::IsInitialized() const {

  return true;
}

void MessageReference::Swap(MessageReference* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MessageReference::InternalSwap(MessageReference* other) {
  id_.Swap(&other->id_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string MessageReference::GetTypeName() const {
  return "MessageReference";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MessageReference

// optional bytes id = 1;
void MessageReference::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& MessageReference::id() const {
  // @@protoc_insertion_point(field_get:MessageReference.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MessageReference::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageReference.id)
}
 void MessageReference::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageReference.id)
}
 void MessageReference::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageReference.id)
}
 ::std::string* MessageReference::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:MessageReference.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MessageReference::release_id() {
  // @@protoc_insertion_point(field_release:MessageReference.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MessageReference::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:MessageReference.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignedMessage::kPostFieldNumber;
const int SignedMessage::kSignedMessageFieldNumber;
const int SignedMessage::kPrivateKeyFieldNumber;
const int SignedMessage::kPublicKeyFieldNumber;
const int SignedMessage::kSymmetriclyEncryptedMessageFieldNumber;
const int SignedMessage::kAsymmetriclyEncryptedMessageFieldNumber;
const int SignedMessage::kReferenceFieldNumber;
const int SignedMessage::kMessageSignatureFieldNumber;
const int SignedMessage::kTimestampFieldNumber;
const int SignedMessage::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignedMessage::SignedMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SignedMessage)
}

void SignedMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_signature_ = const_cast< ::Signature*>(
      ::Signature::internal_default_instance());
#else
  message_signature_ = const_cast< ::Signature*>(&::Signature::default_instance());
#endif
}

SignedMessage::SignedMessage(const SignedMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SignedMessage)
}

void SignedMessage::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_signature_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}

SignedMessage::~SignedMessage() {
  // @@protoc_insertion_point(destructor:SignedMessage)
  SharedDtor();
}

void SignedMessage::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_msg()) {
    clear_msg();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_signature_;
  }
}

void SignedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignedMessage& SignedMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

SignedMessage* SignedMessage::default_instance_ = NULL;

SignedMessage* SignedMessage::New(::google::protobuf::Arena* arena) const {
  SignedMessage* n = new SignedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SignedMessage::clear_msg() {
// @@protoc_insertion_point(one_of_clear_start:SignedMessage)
  switch(msg_case()) {
    case kPost: {
      delete msg_.post_;
      break;
    }
    case kSignedMessage: {
      delete msg_.signedmessage_;
      break;
    }
    case kPrivateKey: {
      delete msg_.privatekey_;
      break;
    }
    case kPublicKey: {
      delete msg_.publickey_;
      break;
    }
    case kSymmetriclyEncryptedMessage: {
      delete msg_.symmetriclyencryptedmessage_;
      break;
    }
    case kAsymmetriclyEncryptedMessage: {
      delete msg_.asymmetriclyencryptedmessage_;
      break;
    }
    case kReference: {
      delete msg_.reference_;
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MSG_NOT_SET;
}


void SignedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SignedMessage)
  if (GetArenaNoVirtual() == NULL && message_signature_ != NULL) delete message_signature_;
  message_signature_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_msg();
}

bool SignedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SignedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Post post = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_post()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signedMessage;
        break;
      }

      // optional .Signature signedMessage = 2;
      case 2: {
        if (tag == 18) {
         parse_signedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signedmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_privateKey;
        break;
      }

      // optional .PrivateKey privateKey = 3;
      case 3: {
        if (tag == 26) {
         parse_privateKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_privatekey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_publicKey;
        break;
      }

      // optional .PublicKey publicKey = 4;
      case 4: {
        if (tag == 34) {
         parse_publicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_publickey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_symmetriclyEncryptedMessage;
        break;
      }

      // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
      case 5: {
        if (tag == 42) {
         parse_symmetriclyEncryptedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_symmetriclyencryptedmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_asymmetriclyEncryptedMessage;
        break;
      }

      // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
      case 6: {
        if (tag == 50) {
         parse_asymmetriclyEncryptedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_asymmetriclyencryptedmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_message_signature;
        break;
      }

      // optional .Signature message_signature = 8;
      case 8: {
        if (tag == 66) {
         parse_message_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_timestamp;
        break;
      }

      // optional fixed64 timestamp = 9;
      case 9: {
        if (tag == 73) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &timestamp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_reference;
        break;
      }

      // optional .MessageReference reference = 10;
      case 10: {
        if (tag == 82) {
         parse_reference:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reference()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_id;
        break;
      }

      // optional bytes id = 11;
      case 11: {
        if (tag == 90) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SignedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SignedMessage)
  return false;
#undef DO_
}

void SignedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SignedMessage)
  // optional .Post post = 1;
  if (has_post()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *msg_.post_, output);
  }

  // optional .Signature signedMessage = 2;
  if (has_signedmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *msg_.signedmessage_, output);
  }

  // optional .PrivateKey privateKey = 3;
  if (has_privatekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *msg_.privatekey_, output);
  }

  // optional .PublicKey publicKey = 4;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *msg_.publickey_, output);
  }

  // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
  if (has_symmetriclyencryptedmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *msg_.symmetriclyencryptedmessage_, output);
  }

  // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
  if (has_asymmetriclyencryptedmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *msg_.asymmetriclyencryptedmessage_, output);
  }

  // optional .Signature message_signature = 8;
  if (this->has_message_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->message_signature_, output);
  }

  // optional fixed64 timestamp = 9;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(9, this->timestamp(), output);
  }

  // optional .MessageReference reference = 10;
  if (has_reference()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *msg_.reference_, output);
  }

  // optional bytes id = 11;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->id(), output);
  }

  // @@protoc_insertion_point(serialize_end:SignedMessage)
}

int SignedMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:SignedMessage)
  int total_size = 0;

  // optional .Signature message_signature = 8;
  if (this->has_message_signature()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->message_signature_);
  }

  // optional fixed64 timestamp = 9;
  if (this->timestamp() != 0) {
    total_size += 1 + 8;
  }

  // optional bytes id = 11;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  switch (msg_case()) {
    // optional .Post post = 1;
    case kPost: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.post_);
      break;
    }
    // optional .Signature signedMessage = 2;
    case kSignedMessage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.signedmessage_);
      break;
    }
    // optional .PrivateKey privateKey = 3;
    case kPrivateKey: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.privatekey_);
      break;
    }
    // optional .PublicKey publicKey = 4;
    case kPublicKey: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.publickey_);
      break;
    }
    // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
    case kSymmetriclyEncryptedMessage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.symmetriclyencryptedmessage_);
      break;
    }
    // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
    case kAsymmetriclyEncryptedMessage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.asymmetriclyencryptedmessage_);
      break;
    }
    // optional .MessageReference reference = 10;
    case kReference: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.reference_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SignedMessage*>(&from));
}

void SignedMessage::MergeFrom(const SignedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SignedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.msg_case()) {
    case kPost: {
      mutable_post()->::Post::MergeFrom(from.post());
      break;
    }
    case kSignedMessage: {
      mutable_signedmessage()->::Signature::MergeFrom(from.signedmessage());
      break;
    }
    case kPrivateKey: {
      mutable_privatekey()->::PrivateKey::MergeFrom(from.privatekey());
      break;
    }
    case kPublicKey: {
      mutable_publickey()->::PublicKey::MergeFrom(from.publickey());
      break;
    }
    case kSymmetriclyEncryptedMessage: {
      mutable_symmetriclyencryptedmessage()->::SymmetriclyEncryptedMessage::MergeFrom(from.symmetriclyencryptedmessage());
      break;
    }
    case kAsymmetriclyEncryptedMessage: {
      mutable_asymmetriclyencryptedmessage()->::AsymmetriclyEncryptedMessage::MergeFrom(from.asymmetriclyencryptedmessage());
      break;
    }
    case kReference: {
      mutable_reference()->::MessageReference::MergeFrom(from.reference());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  if (from.has_message_signature()) {
    mutable_message_signature()->::Signature::MergeFrom(from.message_signature());
  }
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void SignedMessage::CopyFrom(const SignedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SignedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedMessage::IsInitialized() const {

  return true;
}

void SignedMessage::Swap(SignedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignedMessage::InternalSwap(SignedMessage* other) {
  std::swap(message_signature_, other->message_signature_);
  std::swap(timestamp_, other->timestamp_);
  id_.Swap(&other->id_);
  std::swap(msg_, other->msg_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SignedMessage::GetTypeName() const {
  return "SignedMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SignedMessage

// optional .Post post = 1;
bool SignedMessage::has_post() const {
  return msg_case() == kPost;
}
void SignedMessage::set_has_post() {
  _oneof_case_[0] = kPost;
}
void SignedMessage::clear_post() {
  if (has_post()) {
    delete msg_.post_;
    clear_has_msg();
  }
}
 const ::Post& SignedMessage::post() const {
  // @@protoc_insertion_point(field_get:SignedMessage.post)
  return has_post()
      ? *msg_.post_
      : ::Post::default_instance();
}
::Post* SignedMessage::mutable_post() {
  if (!has_post()) {
    clear_msg();
    set_has_post();
    msg_.post_ = new ::Post;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.post)
  return msg_.post_;
}
::Post* SignedMessage::release_post() {
  // @@protoc_insertion_point(field_release:SignedMessage.post)
  if (has_post()) {
    clear_has_msg();
    ::Post* temp = msg_.post_;
    msg_.post_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_post(::Post* post) {
  clear_msg();
  if (post) {
    set_has_post();
    msg_.post_ = post;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.post)
}

// optional .Signature signedMessage = 2;
bool SignedMessage::has_signedmessage() const {
  return msg_case() == kSignedMessage;
}
void SignedMessage::set_has_signedmessage() {
  _oneof_case_[0] = kSignedMessage;
}
void SignedMessage::clear_signedmessage() {
  if (has_signedmessage()) {
    delete msg_.signedmessage_;
    clear_has_msg();
  }
}
 const ::Signature& SignedMessage::signedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.signedMessage)
  return has_signedmessage()
      ? *msg_.signedmessage_
      : ::Signature::default_instance();
}
::Signature* SignedMessage::mutable_signedmessage() {
  if (!has_signedmessage()) {
    clear_msg();
    set_has_signedmessage();
    msg_.signedmessage_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.signedMessage)
  return msg_.signedmessage_;
}
::Signature* SignedMessage::release_signedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.signedMessage)
  if (has_signedmessage()) {
    clear_has_msg();
    ::Signature* temp = msg_.signedmessage_;
    msg_.signedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_signedmessage(::Signature* signedmessage) {
  clear_msg();
  if (signedmessage) {
    set_has_signedmessage();
    msg_.signedmessage_ = signedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.signedMessage)
}

// optional .PrivateKey privateKey = 3;
bool SignedMessage::has_privatekey() const {
  return msg_case() == kPrivateKey;
}
void SignedMessage::set_has_privatekey() {
  _oneof_case_[0] = kPrivateKey;
}
void SignedMessage::clear_privatekey() {
  if (has_privatekey()) {
    delete msg_.privatekey_;
    clear_has_msg();
  }
}
 const ::PrivateKey& SignedMessage::privatekey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.privateKey)
  return has_privatekey()
      ? *msg_.privatekey_
      : ::PrivateKey::default_instance();
}
::PrivateKey* SignedMessage::mutable_privatekey() {
  if (!has_privatekey()) {
    clear_msg();
    set_has_privatekey();
    msg_.privatekey_ = new ::PrivateKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.privateKey)
  return msg_.privatekey_;
}
::PrivateKey* SignedMessage::release_privatekey() {
  // @@protoc_insertion_point(field_release:SignedMessage.privateKey)
  if (has_privatekey()) {
    clear_has_msg();
    ::PrivateKey* temp = msg_.privatekey_;
    msg_.privatekey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_privatekey(::PrivateKey* privatekey) {
  clear_msg();
  if (privatekey) {
    set_has_privatekey();
    msg_.privatekey_ = privatekey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.privateKey)
}

// optional .PublicKey publicKey = 4;
bool SignedMessage::has_publickey() const {
  return msg_case() == kPublicKey;
}
void SignedMessage::set_has_publickey() {
  _oneof_case_[0] = kPublicKey;
}
void SignedMessage::clear_publickey() {
  if (has_publickey()) {
    delete msg_.publickey_;
    clear_has_msg();
  }
}
 const ::PublicKey& SignedMessage::publickey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.publicKey)
  return has_publickey()
      ? *msg_.publickey_
      : ::PublicKey::default_instance();
}
::PublicKey* SignedMessage::mutable_publickey() {
  if (!has_publickey()) {
    clear_msg();
    set_has_publickey();
    msg_.publickey_ = new ::PublicKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.publicKey)
  return msg_.publickey_;
}
::PublicKey* SignedMessage::release_publickey() {
  // @@protoc_insertion_point(field_release:SignedMessage.publicKey)
  if (has_publickey()) {
    clear_has_msg();
    ::PublicKey* temp = msg_.publickey_;
    msg_.publickey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_publickey(::PublicKey* publickey) {
  clear_msg();
  if (publickey) {
    set_has_publickey();
    msg_.publickey_ = publickey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.publicKey)
}

// optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
bool SignedMessage::has_symmetriclyencryptedmessage() const {
  return msg_case() == kSymmetriclyEncryptedMessage;
}
void SignedMessage::set_has_symmetriclyencryptedmessage() {
  _oneof_case_[0] = kSymmetriclyEncryptedMessage;
}
void SignedMessage::clear_symmetriclyencryptedmessage() {
  if (has_symmetriclyencryptedmessage()) {
    delete msg_.symmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
 const ::SymmetriclyEncryptedMessage& SignedMessage::symmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.symmetriclyEncryptedMessage)
  return has_symmetriclyencryptedmessage()
      ? *msg_.symmetriclyencryptedmessage_
      : ::SymmetriclyEncryptedMessage::default_instance();
}
::SymmetriclyEncryptedMessage* SignedMessage::mutable_symmetriclyencryptedmessage() {
  if (!has_symmetriclyencryptedmessage()) {
    clear_msg();
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.symmetriclyEncryptedMessage)
  return msg_.symmetriclyencryptedmessage_;
}
::SymmetriclyEncryptedMessage* SignedMessage::release_symmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.symmetriclyEncryptedMessage)
  if (has_symmetriclyencryptedmessage()) {
    clear_has_msg();
    ::SymmetriclyEncryptedMessage* temp = msg_.symmetriclyencryptedmessage_;
    msg_.symmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_symmetriclyencryptedmessage(::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage) {
  clear_msg();
  if (symmetriclyencryptedmessage) {
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = symmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.symmetriclyEncryptedMessage)
}

// optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
bool SignedMessage::has_asymmetriclyencryptedmessage() const {
  return msg_case() == kAsymmetriclyEncryptedMessage;
}
void SignedMessage::set_has_asymmetriclyencryptedmessage() {
  _oneof_case_[0] = kAsymmetriclyEncryptedMessage;
}
void SignedMessage::clear_asymmetriclyencryptedmessage() {
  if (has_asymmetriclyencryptedmessage()) {
    delete msg_.asymmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
 const ::AsymmetriclyEncryptedMessage& SignedMessage::asymmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.asymmetriclyEncryptedMessage)
  return has_asymmetriclyencryptedmessage()
      ? *msg_.asymmetriclyencryptedmessage_
      : ::AsymmetriclyEncryptedMessage::default_instance();
}
::AsymmetriclyEncryptedMessage* SignedMessage::mutable_asymmetriclyencryptedmessage() {
  if (!has_asymmetriclyencryptedmessage()) {
    clear_msg();
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = new ::AsymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.asymmetriclyEncryptedMessage)
  return msg_.asymmetriclyencryptedmessage_;
}
::AsymmetriclyEncryptedMessage* SignedMessage::release_asymmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.asymmetriclyEncryptedMessage)
  if (has_asymmetriclyencryptedmessage()) {
    clear_has_msg();
    ::AsymmetriclyEncryptedMessage* temp = msg_.asymmetriclyencryptedmessage_;
    msg_.asymmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_asymmetriclyencryptedmessage(::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage) {
  clear_msg();
  if (asymmetriclyencryptedmessage) {
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = asymmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.asymmetriclyEncryptedMessage)
}

// optional .MessageReference reference = 10;
bool SignedMessage::has_reference() const {
  return msg_case() == kReference;
}
void SignedMessage::set_has_reference() {
  _oneof_case_[0] = kReference;
}
void SignedMessage::clear_reference() {
  if (has_reference()) {
    delete msg_.reference_;
    clear_has_msg();
  }
}
 const ::MessageReference& SignedMessage::reference() const {
  // @@protoc_insertion_point(field_get:SignedMessage.reference)
  return has_reference()
      ? *msg_.reference_
      : ::MessageReference::default_instance();
}
::MessageReference* SignedMessage::mutable_reference() {
  if (!has_reference()) {
    clear_msg();
    set_has_reference();
    msg_.reference_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.reference)
  return msg_.reference_;
}
::MessageReference* SignedMessage::release_reference() {
  // @@protoc_insertion_point(field_release:SignedMessage.reference)
  if (has_reference()) {
    clear_has_msg();
    ::MessageReference* temp = msg_.reference_;
    msg_.reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_reference(::MessageReference* reference) {
  clear_msg();
  if (reference) {
    set_has_reference();
    msg_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.reference)
}

// optional .Signature message_signature = 8;
bool SignedMessage::has_message_signature() const {
  return !_is_default_instance_ && message_signature_ != NULL;
}
void SignedMessage::clear_message_signature() {
  if (GetArenaNoVirtual() == NULL && message_signature_ != NULL) delete message_signature_;
  message_signature_ = NULL;
}
const ::Signature& SignedMessage::message_signature() const {
  // @@protoc_insertion_point(field_get:SignedMessage.message_signature)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_signature_ != NULL ? *message_signature_ : *default_instance().message_signature_;
#else
  return message_signature_ != NULL ? *message_signature_ : *default_instance_->message_signature_;
#endif
}
::Signature* SignedMessage::mutable_message_signature() {
  
  if (message_signature_ == NULL) {
    message_signature_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.message_signature)
  return message_signature_;
}
::Signature* SignedMessage::release_message_signature() {
  // @@protoc_insertion_point(field_release:SignedMessage.message_signature)
  
  ::Signature* temp = message_signature_;
  message_signature_ = NULL;
  return temp;
}
void SignedMessage::set_allocated_message_signature(::Signature* message_signature) {
  delete message_signature_;
  message_signature_ = message_signature;
  if (message_signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.message_signature)
}

// optional fixed64 timestamp = 9;
void SignedMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 SignedMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:SignedMessage.timestamp)
  return timestamp_;
}
 void SignedMessage::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SignedMessage.timestamp)
}

// optional bytes id = 11;
void SignedMessage::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SignedMessage::id() const {
  // @@protoc_insertion_point(field_get:SignedMessage.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SignedMessage::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignedMessage.id)
}
 void SignedMessage::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignedMessage.id)
}
 void SignedMessage::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignedMessage.id)
}
 ::std::string* SignedMessage::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:SignedMessage.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SignedMessage::release_id() {
  // @@protoc_insertion_point(field_release:SignedMessage.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SignedMessage::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.id)
}

bool SignedMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
void SignedMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
SignedMessage::MsgCase SignedMessage::msg_case() const {
  return SignedMessage::MsgCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
