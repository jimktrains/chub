// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Post_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Post_reflection_ = NULL;
const ::google::protobuf::Descriptor* Signature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Signature_reflection_ = NULL;
const ::google::protobuf::Descriptor* PrivateKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PrivateKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* PublicKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PublicKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* SymmetriclyEncryptedMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SymmetriclyEncryptedMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* AsymmetriclyEncryptedMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AsymmetriclyEncryptedMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* HybridEncryptedMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HybridEncryptedMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* MessageReference_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MessageReference_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignedMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignedMessage_reflection_ = NULL;
struct SignedMessageOneofInstance {
  const ::Post* post_;
  const ::Signature* signedmessage_;
  const ::PrivateKey* privatekey_;
  const ::PublicKey* publickey_;
  const ::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage_;
  const ::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage_;
  const ::HybridEncryptedMessage* hybridencryptedmessage_;
  const ::MessageReference* reference_;
}* SignedMessage_default_oneof_instance_ = NULL;
const ::google::protobuf::EnumDescriptor* SignatureType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ECCKeyType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EncryptionType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KeyEncodingType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_message_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_message_2eproto() {
  protobuf_AddDesc_message_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "message.proto");
  GOOGLE_CHECK(file != NULL);
  Post_descriptor_ = file->message_type(0);
  static const int Post_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, title_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, start_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, all_day_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, end_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, rsvp_by_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, rsvp_email_),
  };
  Post_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Post_descriptor_,
      Post::default_instance_,
      Post_offsets_,
      -1,
      -1,
      -1,
      sizeof(Post),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Post, _is_default_instance_));
  Signature_descriptor_ = file->message_type(1);
  static const int Signature_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signature, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signature, signature_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signature, fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signature, ref_),
  };
  Signature_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Signature_descriptor_,
      Signature::default_instance_,
      Signature_offsets_,
      -1,
      -1,
      -1,
      sizeof(Signature),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signature, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signature, _is_default_instance_));
  PrivateKey_descriptor_ = file->message_type(2);
  static const int PrivateKey_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, encodingtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, email_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, organization_),
  };
  PrivateKey_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PrivateKey_descriptor_,
      PrivateKey::default_instance_,
      PrivateKey_offsets_,
      -1,
      -1,
      -1,
      sizeof(PrivateKey),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrivateKey, _is_default_instance_));
  PublicKey_descriptor_ = file->message_type(3);
  static const int PublicKey_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, encodingtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, ref_),
  };
  PublicKey_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PublicKey_descriptor_,
      PublicKey::default_instance_,
      PublicKey_offsets_,
      -1,
      -1,
      -1,
      sizeof(PublicKey),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _is_default_instance_));
  SymmetriclyEncryptedMessage_descriptor_ = file->message_type(4);
  static const int SymmetriclyEncryptedMessage_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, message_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, encryption_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, msg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, salt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, ref_),
  };
  SymmetriclyEncryptedMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SymmetriclyEncryptedMessage_descriptor_,
      SymmetriclyEncryptedMessage::default_instance_,
      SymmetriclyEncryptedMessage_offsets_,
      -1,
      -1,
      -1,
      sizeof(SymmetriclyEncryptedMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SymmetriclyEncryptedMessage, _is_default_instance_));
  AsymmetriclyEncryptedMessage_descriptor_ = file->message_type(5);
  static const int AsymmetriclyEncryptedMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsymmetriclyEncryptedMessage, message_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsymmetriclyEncryptedMessage, dest_cn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsymmetriclyEncryptedMessage, msg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsymmetriclyEncryptedMessage, ref_),
  };
  AsymmetriclyEncryptedMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AsymmetriclyEncryptedMessage_descriptor_,
      AsymmetriclyEncryptedMessage::default_instance_,
      AsymmetriclyEncryptedMessage_offsets_,
      -1,
      -1,
      -1,
      sizeof(AsymmetriclyEncryptedMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsymmetriclyEncryptedMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsymmetriclyEncryptedMessage, _is_default_instance_));
  HybridEncryptedMessage_descriptor_ = file->message_type(6);
  static const int HybridEncryptedMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HybridEncryptedMessage, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HybridEncryptedMessage, msg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HybridEncryptedMessage, ref_),
  };
  HybridEncryptedMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HybridEncryptedMessage_descriptor_,
      HybridEncryptedMessage::default_instance_,
      HybridEncryptedMessage_offsets_,
      -1,
      -1,
      -1,
      sizeof(HybridEncryptedMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HybridEncryptedMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HybridEncryptedMessage, _is_default_instance_));
  MessageReference_descriptor_ = file->message_type(7);
  static const int MessageReference_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageReference, id_),
  };
  MessageReference_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MessageReference_descriptor_,
      MessageReference::default_instance_,
      MessageReference_offsets_,
      -1,
      -1,
      -1,
      sizeof(MessageReference),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageReference, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageReference, _is_default_instance_));
  SignedMessage_descriptor_ = file->message_type(8);
  static const int SignedMessage_offsets_[11] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, post_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, signedmessage_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, privatekey_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, publickey_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, symmetriclyencryptedmessage_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, asymmetriclyencryptedmessage_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, hybridencryptedmessage_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(SignedMessage_default_oneof_instance_, reference_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedMessage, message_signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedMessage, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedMessage, msg_),
  };
  SignedMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SignedMessage_descriptor_,
      SignedMessage::default_instance_,
      SignedMessage_offsets_,
      -1,
      -1,
      -1,
      SignedMessage_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedMessage, _oneof_case_[0]),
      sizeof(SignedMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedMessage, _is_default_instance_));
  SignatureType_descriptor_ = file->enum_type(0);
  ECCKeyType_descriptor_ = file->enum_type(1);
  EncryptionType_descriptor_ = file->enum_type(2);
  KeyEncodingType_descriptor_ = file->enum_type(3);
  MessageType_descriptor_ = file->enum_type(4);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_message_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Post_descriptor_, &Post::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Signature_descriptor_, &Signature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PrivateKey_descriptor_, &PrivateKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PublicKey_descriptor_, &PublicKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SymmetriclyEncryptedMessage_descriptor_, &SymmetriclyEncryptedMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AsymmetriclyEncryptedMessage_descriptor_, &AsymmetriclyEncryptedMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HybridEncryptedMessage_descriptor_, &HybridEncryptedMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MessageReference_descriptor_, &MessageReference::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SignedMessage_descriptor_, &SignedMessage::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_message_2eproto() {
  delete Post::default_instance_;
  delete Post_reflection_;
  delete Signature::default_instance_;
  delete Signature_reflection_;
  delete PrivateKey::default_instance_;
  delete PrivateKey_reflection_;
  delete PublicKey::default_instance_;
  delete PublicKey_reflection_;
  delete SymmetriclyEncryptedMessage::default_instance_;
  delete SymmetriclyEncryptedMessage_reflection_;
  delete AsymmetriclyEncryptedMessage::default_instance_;
  delete AsymmetriclyEncryptedMessage_reflection_;
  delete HybridEncryptedMessage::default_instance_;
  delete HybridEncryptedMessage_reflection_;
  delete MessageReference::default_instance_;
  delete MessageReference_reflection_;
  delete SignedMessage::default_instance_;
  delete SignedMessage_default_oneof_instance_;
  delete SignedMessage_reflection_;
}

void protobuf_AddDesc_message_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_message_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rmessage.proto\"\263\001\n\004Post\022\n\n\002id\030\001 \001(\t\022\r\n\005"
    "title\030\002 \001(\t\022\023\n\013description\030\003 \001(\t\022\020\n\010loca"
    "tion\030\004 \001(\t\022\022\n\nstart_time\030\005 \001(\006\022\017\n\007all_da"
    "y\030\006 \001(\010\022\020\n\010end_time\030\007 \001(\006\022\r\n\005image\030\010 \001(\014"
    "\022\017\n\007rsvp_by\030\t \001(\006\022\022\n\nrsvp_email\030\n \001(\t\"{\n"
    "\tSignature\022\021\n\tsignature\030\002 \001(\014\022&\n\016signatu"
    "re_type\030\003 \001(\0162\016.SignatureType\022\023\n\013fingerp"
    "rint\030\004 \001(\014\022\036\n\003ref\030\005 \001(\0132\021.MessageReferen"
    "ce\"\255\001\n\nPrivateKey\022)\n\003key\030\002 \001(\0132\034.Symmetr"
    "iclyEncryptedMessage\022\031\n\004type\030\003 \001(\0162\013.ECC"
    "KeyType\022&\n\014encodingType\030\005 \001(\0162\020.KeyEncod"
    "ingType\022\014\n\004name\030\006 \001(\t\022\r\n\005email\030\007 \001(\t\022\024\n\014"
    "organization\030\010 \001(\t\"\220\001\n\tPublicKey\022\013\n\003key\030"
    "\002 \001(\014\022\031\n\004type\030\003 \001(\0162\013.ECCKeyType\022&\n\014enco"
    "dingType\030\004 \001(\0162\020.KeyEncodingType\022\023\n\013fing"
    "erprint\030\005 \001(\014\022\036\n\003ref\030\006 \001(\0132\021.MessageRefe"
    "rence\"\262\001\n\033SymmetriclyEncryptedMessage\022\"\n"
    "\014message_type\030\001 \001(\0162\014.MessageType\022(\n\017enc"
    "ryption_type\030\002 \001(\0162\017.EncryptionType\022\013\n\003m"
    "sg\030\003 \001(\014\022\n\n\002iv\030\004 \001(\014\022\014\n\004salt\030\005 \001(\014\022\036\n\003re"
    "f\030\006 \001(\0132\021.MessageReference\"\200\001\n\034Asymmetri"
    "clyEncryptedMessage\022\"\n\014message_type\030\001 \001("
    "\0162\014.MessageType\022\017\n\007dest_cn\030\002 \001(\t\022\013\n\003msg\030"
    "\004 \001(\014\022\036\n\003ref\030\005 \001(\0132\021.MessageReference\"\217\001"
    "\n\026HybridEncryptedMessage\022*\n\003key\030\001 \001(\0132\035."
    "AsymmetriclyEncryptedMessage\022)\n\003msg\030\002 \001("
    "\0132\034.SymmetriclyEncryptedMessage\022\036\n\003ref\030\003"
    " \001(\0132\021.MessageReference\"\036\n\020MessageRefere"
    "nce\022\n\n\002id\030\001 \001(\014\"\277\003\n\rSignedMessage\022\025\n\004pos"
    "t\030\001 \001(\0132\005.PostH\000\022#\n\rsignedMessage\030\002 \001(\0132"
    "\n.SignatureH\000\022!\n\nprivateKey\030\003 \001(\0132\013.Priv"
    "ateKeyH\000\022\037\n\tpublicKey\030\004 \001(\0132\n.PublicKeyH"
    "\000\022C\n\033symmetriclyEncryptedMessage\030\005 \001(\0132\034"
    ".SymmetriclyEncryptedMessageH\000\022E\n\034asymme"
    "triclyEncryptedMessage\030\006 \001(\0132\035.Asymmetri"
    "clyEncryptedMessageH\000\0229\n\026hybridEncrypted"
    "Message\030\007 \001(\0132\027.HybridEncryptedMessageH\000"
    "\022&\n\treference\030\n \001(\0132\021.MessageReferenceH\000"
    "\022%\n\021message_signature\030\010 \001(\0132\n.Signature\022"
    "\021\n\ttimestamp\030\t \001(\006B\005\n\003msg*$\n\rSignatureTy"
    "pe\022\023\n\017SHA512withECDSA\020\000*\033\n\nECCKeyType\022\r\n"
    "\tsecp384r1\020\000*@\n\016EncryptionType\022.\n*AES_25"
    "6_GCM_PBKDF2WithHmacSHA256_65536_128\020\000*&"
    "\n\017KeyEncodingType\022\t\n\005pkcs8\020\000\022\010\n\004x509\020\001*\212"
    "\002\n\013MessageType\022\017\n\013MessagePost\020\000\022\024\n\020Messa"
    "geSignature\020\001\022\025\n\021MessagePrivateKey\020\002\022\024\n\020"
    "MessagePublicKey\020\003\022&\n\"MessageSymmetricly"
    "EncryptedMessage\020\004\022\'\n#MessageAsymmetricl"
    "yEncryptedMessage\020\005\022!\n\035MessageHybridEncr"
    "yptedMessage\020\006\022\033\n\027MessageReferenceMessag"
    "e\020\007\022\026\n\022MessageSymetricKey\020dB\"\n\027org.metam"
    "esh.chub.protoB\007Messageb\006proto3", 2071);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "message.proto", &protobuf_RegisterTypes);
  Post::default_instance_ = new Post();
  Signature::default_instance_ = new Signature();
  PrivateKey::default_instance_ = new PrivateKey();
  PublicKey::default_instance_ = new PublicKey();
  SymmetriclyEncryptedMessage::default_instance_ = new SymmetriclyEncryptedMessage();
  AsymmetriclyEncryptedMessage::default_instance_ = new AsymmetriclyEncryptedMessage();
  HybridEncryptedMessage::default_instance_ = new HybridEncryptedMessage();
  MessageReference::default_instance_ = new MessageReference();
  SignedMessage::default_instance_ = new SignedMessage();
  SignedMessage_default_oneof_instance_ = new SignedMessageOneofInstance();
  Post::default_instance_->InitAsDefaultInstance();
  Signature::default_instance_->InitAsDefaultInstance();
  PrivateKey::default_instance_->InitAsDefaultInstance();
  PublicKey::default_instance_->InitAsDefaultInstance();
  SymmetriclyEncryptedMessage::default_instance_->InitAsDefaultInstance();
  AsymmetriclyEncryptedMessage::default_instance_->InitAsDefaultInstance();
  HybridEncryptedMessage::default_instance_->InitAsDefaultInstance();
  MessageReference::default_instance_->InitAsDefaultInstance();
  SignedMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_message_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_message_2eproto {
  StaticDescriptorInitializer_message_2eproto() {
    protobuf_AddDesc_message_2eproto();
  }
} static_descriptor_initializer_message_2eproto_;
const ::google::protobuf::EnumDescriptor* SignatureType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignatureType_descriptor_;
}
bool SignatureType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ECCKeyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ECCKeyType_descriptor_;
}
bool ECCKeyType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EncryptionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EncryptionType_descriptor_;
}
bool EncryptionType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* KeyEncodingType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyEncodingType_descriptor_;
}
bool KeyEncodingType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageType_descriptor_;
}
bool MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 100:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Post::kIdFieldNumber;
const int Post::kTitleFieldNumber;
const int Post::kDescriptionFieldNumber;
const int Post::kLocationFieldNumber;
const int Post::kStartTimeFieldNumber;
const int Post::kAllDayFieldNumber;
const int Post::kEndTimeFieldNumber;
const int Post::kImageFieldNumber;
const int Post::kRsvpByFieldNumber;
const int Post::kRsvpEmailFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Post::Post()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Post)
}

void Post::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Post::Post(const Post& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Post)
}

void Post::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  start_time_ = GOOGLE_ULONGLONG(0);
  all_day_ = false;
  end_time_ = GOOGLE_ULONGLONG(0);
  image_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rsvp_by_ = GOOGLE_ULONGLONG(0);
  rsvp_email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Post::~Post() {
  // @@protoc_insertion_point(destructor:Post)
  SharedDtor();
}

void Post::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  image_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rsvp_email_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Post::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Post::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Post_descriptor_;
}

const Post& Post::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

Post* Post::default_instance_ = NULL;

Post* Post::New(::google::protobuf::Arena* arena) const {
  Post* n = new Post;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Post::Clear() {
// @@protoc_insertion_point(message_clear_start:Post)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Post, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Post*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(start_time_, end_time_);
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  all_day_ = false;
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rsvp_by_ = GOOGLE_ULONGLONG(0);
  rsvp_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool Post::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Post)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.id"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_title;
        break;
      }

      // optional string title = 2;
      case 2: {
        if (tag == 18) {
         parse_title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->title().data(), this->title().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.title"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_description;
        break;
      }

      // optional string description = 3;
      case 3: {
        if (tag == 26) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.description"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // optional string location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->location().data(), this->location().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.location"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_start_time;
        break;
      }

      // optional fixed64 start_time = 5;
      case 5: {
        if (tag == 41) {
         parse_start_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &start_time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_all_day;
        break;
      }

      // optional bool all_day = 6;
      case 6: {
        if (tag == 48) {
         parse_all_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &all_day_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_end_time;
        break;
      }

      // optional fixed64 end_time = 7;
      case 7: {
        if (tag == 57) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &end_time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_image;
        break;
      }

      // optional bytes image = 8;
      case 8: {
        if (tag == 66) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_rsvp_by;
        break;
      }

      // optional fixed64 rsvp_by = 9;
      case 9: {
        if (tag == 73) {
         parse_rsvp_by:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &rsvp_by_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_rsvp_email;
        break;
      }

      // optional string rsvp_email = 10;
      case 10: {
        if (tag == 82) {
         parse_rsvp_email:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rsvp_email()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->rsvp_email().data(), this->rsvp_email().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Post.rsvp_email"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Post)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Post)
  return false;
#undef DO_
}

void Post::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Post)
  // optional string id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // optional string title = 2;
  if (this->title().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.title");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->title(), output);
  }

  // optional string description = 3;
  if (this->description().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.description");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->description(), output);
  }

  // optional string location = 4;
  if (this->location().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.location");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->location(), output);
  }

  // optional fixed64 start_time = 5;
  if (this->start_time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(5, this->start_time(), output);
  }

  // optional bool all_day = 6;
  if (this->all_day() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->all_day(), output);
  }

  // optional fixed64 end_time = 7;
  if (this->end_time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(7, this->end_time(), output);
  }

  // optional bytes image = 8;
  if (this->image().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->image(), output);
  }

  // optional fixed64 rsvp_by = 9;
  if (this->rsvp_by() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(9, this->rsvp_by(), output);
  }

  // optional string rsvp_email = 10;
  if (this->rsvp_email().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->rsvp_email().data(), this->rsvp_email().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.rsvp_email");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->rsvp_email(), output);
  }

  // @@protoc_insertion_point(serialize_end:Post)
}

::google::protobuf::uint8* Post::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Post)
  // optional string id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // optional string title = 2;
  if (this->title().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.title");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->title(), target);
  }

  // optional string description = 3;
  if (this->description().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.description");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->description(), target);
  }

  // optional string location = 4;
  if (this->location().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.location");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->location(), target);
  }

  // optional fixed64 start_time = 5;
  if (this->start_time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(5, this->start_time(), target);
  }

  // optional bool all_day = 6;
  if (this->all_day() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->all_day(), target);
  }

  // optional fixed64 end_time = 7;
  if (this->end_time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(7, this->end_time(), target);
  }

  // optional bytes image = 8;
  if (this->image().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->image(), target);
  }

  // optional fixed64 rsvp_by = 9;
  if (this->rsvp_by() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(9, this->rsvp_by(), target);
  }

  // optional string rsvp_email = 10;
  if (this->rsvp_email().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->rsvp_email().data(), this->rsvp_email().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Post.rsvp_email");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->rsvp_email(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Post)
  return target;
}

int Post::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Post)
  int total_size = 0;

  // optional string id = 1;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  // optional string title = 2;
  if (this->title().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->title());
  }

  // optional string description = 3;
  if (this->description().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->description());
  }

  // optional string location = 4;
  if (this->location().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->location());
  }

  // optional fixed64 start_time = 5;
  if (this->start_time() != 0) {
    total_size += 1 + 8;
  }

  // optional bool all_day = 6;
  if (this->all_day() != 0) {
    total_size += 1 + 1;
  }

  // optional fixed64 end_time = 7;
  if (this->end_time() != 0) {
    total_size += 1 + 8;
  }

  // optional bytes image = 8;
  if (this->image().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->image());
  }

  // optional fixed64 rsvp_by = 9;
  if (this->rsvp_by() != 0) {
    total_size += 1 + 8;
  }

  // optional string rsvp_email = 10;
  if (this->rsvp_email().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->rsvp_email());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Post::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Post)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Post* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Post>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Post)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Post)
    MergeFrom(*source);
  }
}

void Post::MergeFrom(const Post& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Post)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  if (from.title().size() > 0) {

    title_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.title_);
  }
  if (from.description().size() > 0) {

    description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  if (from.location().size() > 0) {

    location_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.location_);
  }
  if (from.start_time() != 0) {
    set_start_time(from.start_time());
  }
  if (from.all_day() != 0) {
    set_all_day(from.all_day());
  }
  if (from.end_time() != 0) {
    set_end_time(from.end_time());
  }
  if (from.image().size() > 0) {

    image_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.image_);
  }
  if (from.rsvp_by() != 0) {
    set_rsvp_by(from.rsvp_by());
  }
  if (from.rsvp_email().size() > 0) {

    rsvp_email_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.rsvp_email_);
  }
}

void Post::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Post)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Post::CopyFrom(const Post& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Post)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Post::IsInitialized() const {

  return true;
}

void Post::Swap(Post* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Post::InternalSwap(Post* other) {
  id_.Swap(&other->id_);
  title_.Swap(&other->title_);
  description_.Swap(&other->description_);
  location_.Swap(&other->location_);
  std::swap(start_time_, other->start_time_);
  std::swap(all_day_, other->all_day_);
  std::swap(end_time_, other->end_time_);
  image_.Swap(&other->image_);
  std::swap(rsvp_by_, other->rsvp_by_);
  rsvp_email_.Swap(&other->rsvp_email_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Post::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Post_descriptor_;
  metadata.reflection = Post_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Post

// optional string id = 1;
void Post::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::id() const {
  // @@protoc_insertion_point(field_get:Post.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.id)
}
 void Post::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.id)
}
 void Post::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.id)
}
 ::std::string* Post::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:Post.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_id() {
  // @@protoc_insertion_point(field_release:Post.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Post.id)
}

// optional string title = 2;
void Post::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::title() const {
  // @@protoc_insertion_point(field_get:Post.title)
  return title_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.title)
}
 void Post::set_title(const char* value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.title)
}
 void Post::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.title)
}
 ::std::string* Post::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:Post.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_title() {
  // @@protoc_insertion_point(field_release:Post.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:Post.title)
}

// optional string description = 3;
void Post::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::description() const {
  // @@protoc_insertion_point(field_get:Post.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.description)
}
 void Post::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.description)
}
 void Post::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.description)
}
 ::std::string* Post::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:Post.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_description() {
  // @@protoc_insertion_point(field_release:Post.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:Post.description)
}

// optional string location = 4;
void Post::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::location() const {
  // @@protoc_insertion_point(field_get:Post.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.location)
}
 void Post::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.location)
}
 void Post::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.location)
}
 ::std::string* Post::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Post.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_location() {
  // @@protoc_insertion_point(field_release:Post.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Post.location)
}

// optional fixed64 start_time = 5;
void Post::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Post::start_time() const {
  // @@protoc_insertion_point(field_get:Post.start_time)
  return start_time_;
}
 void Post::set_start_time(::google::protobuf::uint64 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:Post.start_time)
}

// optional bool all_day = 6;
void Post::clear_all_day() {
  all_day_ = false;
}
 bool Post::all_day() const {
  // @@protoc_insertion_point(field_get:Post.all_day)
  return all_day_;
}
 void Post::set_all_day(bool value) {
  
  all_day_ = value;
  // @@protoc_insertion_point(field_set:Post.all_day)
}

// optional fixed64 end_time = 7;
void Post::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Post::end_time() const {
  // @@protoc_insertion_point(field_get:Post.end_time)
  return end_time_;
}
 void Post::set_end_time(::google::protobuf::uint64 value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:Post.end_time)
}

// optional bytes image = 8;
void Post::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::image() const {
  // @@protoc_insertion_point(field_get:Post.image)
  return image_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.image)
}
 void Post::set_image(const char* value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.image)
}
 void Post::set_image(const void* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.image)
}
 ::std::string* Post::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:Post.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_image() {
  // @@protoc_insertion_point(field_release:Post.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:Post.image)
}

// optional fixed64 rsvp_by = 9;
void Post::clear_rsvp_by() {
  rsvp_by_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Post::rsvp_by() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_by)
  return rsvp_by_;
}
 void Post::set_rsvp_by(::google::protobuf::uint64 value) {
  
  rsvp_by_ = value;
  // @@protoc_insertion_point(field_set:Post.rsvp_by)
}

// optional string rsvp_email = 10;
void Post::clear_rsvp_email() {
  rsvp_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Post::rsvp_email() const {
  // @@protoc_insertion_point(field_get:Post.rsvp_email)
  return rsvp_email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_rsvp_email(const ::std::string& value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Post.rsvp_email)
}
 void Post::set_rsvp_email(const char* value) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Post.rsvp_email)
}
 void Post::set_rsvp_email(const char* value, size_t size) {
  
  rsvp_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Post.rsvp_email)
}
 ::std::string* Post::mutable_rsvp_email() {
  
  // @@protoc_insertion_point(field_mutable:Post.rsvp_email)
  return rsvp_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Post::release_rsvp_email() {
  // @@protoc_insertion_point(field_release:Post.rsvp_email)
  
  return rsvp_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Post::set_allocated_rsvp_email(::std::string* rsvp_email) {
  if (rsvp_email != NULL) {
    
  } else {
    
  }
  rsvp_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rsvp_email);
  // @@protoc_insertion_point(field_set_allocated:Post.rsvp_email)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Signature::kSignatureFieldNumber;
const int Signature::kSignatureTypeFieldNumber;
const int Signature::kFingerprintFieldNumber;
const int Signature::kRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Signature::Signature()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Signature)
}

void Signature::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  ref_ = const_cast< ::MessageReference*>(&::MessageReference::default_instance());
}

Signature::Signature(const Signature& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Signature)
}

void Signature::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_type_ = 0;
  fingerprint_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ref_ = NULL;
}

Signature::~Signature() {
  // @@protoc_insertion_point(destructor:Signature)
  SharedDtor();
}

void Signature::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fingerprint_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete ref_;
  }
}

void Signature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Signature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Signature_descriptor_;
}

const Signature& Signature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

Signature* Signature::default_instance_ = NULL;

Signature* Signature::New(::google::protobuf::Arena* arena) const {
  Signature* n = new Signature;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Signature::Clear() {
// @@protoc_insertion_point(message_clear_start:Signature)
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_type_ = 0;
  fingerprint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}

bool Signature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Signature)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes signature = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_signature_type;
        break;
      }

      // optional .SignatureType signature_type = 3;
      case 3: {
        if (tag == 24) {
         parse_signature_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_signature_type(static_cast< ::SignatureType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_fingerprint;
        break;
      }

      // optional bytes fingerprint = 4;
      case 4: {
        if (tag == 34) {
         parse_fingerprint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ref;
        break;
      }

      // optional .MessageReference ref = 5;
      case 5: {
        if (tag == 42) {
         parse_ref:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Signature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Signature)
  return false;
#undef DO_
}

void Signature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Signature)
  // optional bytes signature = 2;
  if (this->signature().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional .SignatureType signature_type = 3;
  if (this->signature_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->signature_type(), output);
  }

  // optional bytes fingerprint = 4;
  if (this->fingerprint().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->fingerprint(), output);
  }

  // optional .MessageReference ref = 5;
  if (this->has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->ref_, output);
  }

  // @@protoc_insertion_point(serialize_end:Signature)
}

::google::protobuf::uint8* Signature::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Signature)
  // optional bytes signature = 2;
  if (this->signature().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional .SignatureType signature_type = 3;
  if (this->signature_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->signature_type(), target);
  }

  // optional bytes fingerprint = 4;
  if (this->fingerprint().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->fingerprint(), target);
  }

  // optional .MessageReference ref = 5;
  if (this->has_ref()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->ref_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Signature)
  return target;
}

int Signature::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Signature)
  int total_size = 0;

  // optional bytes signature = 2;
  if (this->signature().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  // optional .SignatureType signature_type = 3;
  if (this->signature_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->signature_type());
  }

  // optional bytes fingerprint = 4;
  if (this->fingerprint().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->fingerprint());
  }

  // optional .MessageReference ref = 5;
  if (this->has_ref()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->ref_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Signature::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Signature)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Signature* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Signature>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Signature)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Signature)
    MergeFrom(*source);
  }
}

void Signature::MergeFrom(const Signature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Signature)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.signature().size() > 0) {

    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  if (from.signature_type() != 0) {
    set_signature_type(from.signature_type());
  }
  if (from.fingerprint().size() > 0) {

    fingerprint_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fingerprint_);
  }
  if (from.has_ref()) {
    mutable_ref()->::MessageReference::MergeFrom(from.ref());
  }
}

void Signature::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Signature::CopyFrom(const Signature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signature::IsInitialized() const {

  return true;
}

void Signature::Swap(Signature* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Signature::InternalSwap(Signature* other) {
  signature_.Swap(&other->signature_);
  std::swap(signature_type_, other->signature_type_);
  fingerprint_.Swap(&other->fingerprint_);
  std::swap(ref_, other->ref_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Signature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Signature_descriptor_;
  metadata.reflection = Signature_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Signature

// optional bytes signature = 2;
void Signature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Signature::signature() const {
  // @@protoc_insertion_point(field_get:Signature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.signature)
}
 void Signature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.signature)
}
 void Signature::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.signature)
}
 ::std::string* Signature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Signature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Signature::release_signature() {
  // @@protoc_insertion_point(field_release:Signature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Signature.signature)
}

// optional .SignatureType signature_type = 3;
void Signature::clear_signature_type() {
  signature_type_ = 0;
}
 ::SignatureType Signature::signature_type() const {
  // @@protoc_insertion_point(field_get:Signature.signature_type)
  return static_cast< ::SignatureType >(signature_type_);
}
 void Signature::set_signature_type(::SignatureType value) {
  
  signature_type_ = value;
  // @@protoc_insertion_point(field_set:Signature.signature_type)
}

// optional bytes fingerprint = 4;
void Signature::clear_fingerprint() {
  fingerprint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Signature::fingerprint() const {
  // @@protoc_insertion_point(field_get:Signature.fingerprint)
  return fingerprint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_fingerprint(const ::std::string& value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signature.fingerprint)
}
 void Signature::set_fingerprint(const char* value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signature.fingerprint)
}
 void Signature::set_fingerprint(const void* value, size_t size) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signature.fingerprint)
}
 ::std::string* Signature::mutable_fingerprint() {
  
  // @@protoc_insertion_point(field_mutable:Signature.fingerprint)
  return fingerprint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Signature::release_fingerprint() {
  // @@protoc_insertion_point(field_release:Signature.fingerprint)
  
  return fingerprint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Signature::set_allocated_fingerprint(::std::string* fingerprint) {
  if (fingerprint != NULL) {
    
  } else {
    
  }
  fingerprint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fingerprint);
  // @@protoc_insertion_point(field_set_allocated:Signature.fingerprint)
}

// optional .MessageReference ref = 5;
bool Signature::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
void Signature::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
const ::MessageReference& Signature::ref() const {
  // @@protoc_insertion_point(field_get:Signature.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
::MessageReference* Signature::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:Signature.ref)
  return ref_;
}
::MessageReference* Signature::release_ref() {
  // @@protoc_insertion_point(field_release:Signature.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
void Signature::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Signature.ref)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PrivateKey::kKeyFieldNumber;
const int PrivateKey::kTypeFieldNumber;
const int PrivateKey::kEncodingTypeFieldNumber;
const int PrivateKey::kNameFieldNumber;
const int PrivateKey::kEmailFieldNumber;
const int PrivateKey::kOrganizationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PrivateKey::PrivateKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PrivateKey)
}

void PrivateKey::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  key_ = const_cast< ::SymmetriclyEncryptedMessage*>(&::SymmetriclyEncryptedMessage::default_instance());
}

PrivateKey::PrivateKey(const PrivateKey& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PrivateKey)
}

void PrivateKey::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_ = NULL;
  type_ = 0;
  encodingtype_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organization_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

PrivateKey::~PrivateKey() {
  // @@protoc_insertion_point(destructor:PrivateKey)
  SharedDtor();
}

void PrivateKey::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  email_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organization_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete key_;
  }
}

void PrivateKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PrivateKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PrivateKey_descriptor_;
}

const PrivateKey& PrivateKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

PrivateKey* PrivateKey::default_instance_ = NULL;

PrivateKey* PrivateKey::New(::google::protobuf::Arena* arena) const {
  PrivateKey* n = new PrivateKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PrivateKey::Clear() {
// @@protoc_insertion_point(message_clear_start:PrivateKey)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PrivateKey, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PrivateKey*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, encodingtype_);
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool PrivateKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PrivateKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SymmetriclyEncryptedMessage key = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .ECCKeyType type = 3;
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::ECCKeyType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_encodingType;
        break;
      }

      // optional .KeyEncodingType encodingType = 5;
      case 5: {
        if (tag == 40) {
         parse_encodingType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encodingtype(static_cast< ::KeyEncodingType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_name;
        break;
      }

      // optional string name = 6;
      case 6: {
        if (tag == 50) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "PrivateKey.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_email;
        break;
      }

      // optional string email = 7;
      case 7: {
        if (tag == 58) {
         parse_email:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_email()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->email().data(), this->email().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "PrivateKey.email"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_organization;
        break;
      }

      // optional string organization = 8;
      case 8: {
        if (tag == 66) {
         parse_organization:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_organization()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->organization().data(), this->organization().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "PrivateKey.organization"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PrivateKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PrivateKey)
  return false;
#undef DO_
}

void PrivateKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PrivateKey)
  // optional .SymmetriclyEncryptedMessage key = 2;
  if (this->has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->key_, output);
  }

  // optional .ECCKeyType type = 3;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional .KeyEncodingType encodingType = 5;
  if (this->encodingtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->encodingtype(), output);
  }

  // optional string name = 6;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "PrivateKey.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->name(), output);
  }

  // optional string email = 7;
  if (this->email().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->email().data(), this->email().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "PrivateKey.email");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->email(), output);
  }

  // optional string organization = 8;
  if (this->organization().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->organization().data(), this->organization().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "PrivateKey.organization");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->organization(), output);
  }

  // @@protoc_insertion_point(serialize_end:PrivateKey)
}

::google::protobuf::uint8* PrivateKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PrivateKey)
  // optional .SymmetriclyEncryptedMessage key = 2;
  if (this->has_key()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->key_, false, target);
  }

  // optional .ECCKeyType type = 3;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional .KeyEncodingType encodingType = 5;
  if (this->encodingtype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->encodingtype(), target);
  }

  // optional string name = 6;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "PrivateKey.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->name(), target);
  }

  // optional string email = 7;
  if (this->email().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->email().data(), this->email().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "PrivateKey.email");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->email(), target);
  }

  // optional string organization = 8;
  if (this->organization().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->organization().data(), this->organization().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "PrivateKey.organization");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->organization(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:PrivateKey)
  return target;
}

int PrivateKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:PrivateKey)
  int total_size = 0;

  // optional .SymmetriclyEncryptedMessage key = 2;
  if (this->has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->key_);
  }

  // optional .ECCKeyType type = 3;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional .KeyEncodingType encodingType = 5;
  if (this->encodingtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encodingtype());
  }

  // optional string name = 6;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // optional string email = 7;
  if (this->email().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->email());
  }

  // optional string organization = 8;
  if (this->organization().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->organization());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PrivateKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:PrivateKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PrivateKey* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PrivateKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:PrivateKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:PrivateKey)
    MergeFrom(*source);
  }
}

void PrivateKey::MergeFrom(const PrivateKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PrivateKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.has_key()) {
    mutable_key()->::SymmetriclyEncryptedMessage::MergeFrom(from.key());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.encodingtype() != 0) {
    set_encodingtype(from.encodingtype());
  }
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.email().size() > 0) {

    email_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.email_);
  }
  if (from.organization().size() > 0) {

    organization_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.organization_);
  }
}

void PrivateKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:PrivateKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PrivateKey::CopyFrom(const PrivateKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PrivateKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivateKey::IsInitialized() const {

  return true;
}

void PrivateKey::Swap(PrivateKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PrivateKey::InternalSwap(PrivateKey* other) {
  std::swap(key_, other->key_);
  std::swap(type_, other->type_);
  std::swap(encodingtype_, other->encodingtype_);
  name_.Swap(&other->name_);
  email_.Swap(&other->email_);
  organization_.Swap(&other->organization_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PrivateKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PrivateKey_descriptor_;
  metadata.reflection = PrivateKey_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PrivateKey

// optional .SymmetriclyEncryptedMessage key = 2;
bool PrivateKey::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
void PrivateKey::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
const ::SymmetriclyEncryptedMessage& PrivateKey::key() const {
  // @@protoc_insertion_point(field_get:PrivateKey.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
::SymmetriclyEncryptedMessage* PrivateKey::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:PrivateKey.key)
  return key_;
}
::SymmetriclyEncryptedMessage* PrivateKey::release_key() {
  // @@protoc_insertion_point(field_release:PrivateKey.key)
  
  ::SymmetriclyEncryptedMessage* temp = key_;
  key_ = NULL;
  return temp;
}
void PrivateKey::set_allocated_key(::SymmetriclyEncryptedMessage* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.key)
}

// optional .ECCKeyType type = 3;
void PrivateKey::clear_type() {
  type_ = 0;
}
 ::ECCKeyType PrivateKey::type() const {
  // @@protoc_insertion_point(field_get:PrivateKey.type)
  return static_cast< ::ECCKeyType >(type_);
}
 void PrivateKey::set_type(::ECCKeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PrivateKey.type)
}

// optional .KeyEncodingType encodingType = 5;
void PrivateKey::clear_encodingtype() {
  encodingtype_ = 0;
}
 ::KeyEncodingType PrivateKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PrivateKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
 void PrivateKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PrivateKey.encodingType)
}

// optional string name = 6;
void PrivateKey::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PrivateKey::name() const {
  // @@protoc_insertion_point(field_get:PrivateKey.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.name)
}
 void PrivateKey::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.name)
}
 void PrivateKey::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.name)
}
 ::std::string* PrivateKey::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PrivateKey::release_name() {
  // @@protoc_insertion_point(field_release:PrivateKey.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.name)
}

// optional string email = 7;
void PrivateKey::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PrivateKey::email() const {
  // @@protoc_insertion_point(field_get:PrivateKey.email)
  return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.email)
}
 void PrivateKey::set_email(const char* value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.email)
}
 void PrivateKey::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.email)
}
 ::std::string* PrivateKey::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PrivateKey::release_email() {
  // @@protoc_insertion_point(field_release:PrivateKey.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.email)
}

// optional string organization = 8;
void PrivateKey::clear_organization() {
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PrivateKey::organization() const {
  // @@protoc_insertion_point(field_get:PrivateKey.organization)
  return organization_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_organization(const ::std::string& value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateKey.organization)
}
 void PrivateKey::set_organization(const char* value) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateKey.organization)
}
 void PrivateKey::set_organization(const char* value, size_t size) {
  
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateKey.organization)
}
 ::std::string* PrivateKey::mutable_organization() {
  
  // @@protoc_insertion_point(field_mutable:PrivateKey.organization)
  return organization_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PrivateKey::release_organization() {
  // @@protoc_insertion_point(field_release:PrivateKey.organization)
  
  return organization_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PrivateKey::set_allocated_organization(::std::string* organization) {
  if (organization != NULL) {
    
  } else {
    
  }
  organization_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organization);
  // @@protoc_insertion_point(field_set_allocated:PrivateKey.organization)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PublicKey::kKeyFieldNumber;
const int PublicKey::kTypeFieldNumber;
const int PublicKey::kEncodingTypeFieldNumber;
const int PublicKey::kFingerprintFieldNumber;
const int PublicKey::kRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PublicKey::PublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicKey)
}

void PublicKey::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  ref_ = const_cast< ::MessageReference*>(&::MessageReference::default_instance());
}

PublicKey::PublicKey(const PublicKey& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicKey)
}

void PublicKey::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  encodingtype_ = 0;
  fingerprint_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ref_ = NULL;
}

PublicKey::~PublicKey() {
  // @@protoc_insertion_point(destructor:PublicKey)
  SharedDtor();
}

void PublicKey::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fingerprint_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete ref_;
  }
}

void PublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PublicKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PublicKey_descriptor_;
}

const PublicKey& PublicKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

PublicKey* PublicKey::default_instance_ = NULL;

PublicKey* PublicKey::New(::google::protobuf::Arena* arena) const {
  PublicKey* n = new PublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:PublicKey)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PublicKey, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PublicKey*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, encodingtype_);
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fingerprint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;

#undef ZR_HELPER_
#undef ZR_

}

bool PublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .ECCKeyType type = 3;
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::ECCKeyType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_encodingType;
        break;
      }

      // optional .KeyEncodingType encodingType = 4;
      case 4: {
        if (tag == 32) {
         parse_encodingType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encodingtype(static_cast< ::KeyEncodingType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_fingerprint;
        break;
      }

      // optional bytes fingerprint = 5;
      case 5: {
        if (tag == 42) {
         parse_fingerprint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ref;
        break;
      }

      // optional .MessageReference ref = 6;
      case 6: {
        if (tag == 50) {
         parse_ref:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicKey)
  return false;
#undef DO_
}

void PublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicKey)
  // optional bytes key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->key(), output);
  }

  // optional .ECCKeyType type = 3;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional .KeyEncodingType encodingType = 4;
  if (this->encodingtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->encodingtype(), output);
  }

  // optional bytes fingerprint = 5;
  if (this->fingerprint().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->fingerprint(), output);
  }

  // optional .MessageReference ref = 6;
  if (this->has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->ref_, output);
  }

  // @@protoc_insertion_point(serialize_end:PublicKey)
}

::google::protobuf::uint8* PublicKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicKey)
  // optional bytes key = 2;
  if (this->key().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->key(), target);
  }

  // optional .ECCKeyType type = 3;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional .KeyEncodingType encodingType = 4;
  if (this->encodingtype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->encodingtype(), target);
  }

  // optional bytes fingerprint = 5;
  if (this->fingerprint().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->fingerprint(), target);
  }

  // optional .MessageReference ref = 6;
  if (this->has_ref()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->ref_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:PublicKey)
  return target;
}

int PublicKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:PublicKey)
  int total_size = 0;

  // optional bytes key = 2;
  if (this->key().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->key());
  }

  // optional .ECCKeyType type = 3;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional .KeyEncodingType encodingType = 4;
  if (this->encodingtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encodingtype());
  }

  // optional bytes fingerprint = 5;
  if (this->fingerprint().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->fingerprint());
  }

  // optional .MessageReference ref = 6;
  if (this->has_ref()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->ref_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:PublicKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PublicKey* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PublicKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:PublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:PublicKey)
    MergeFrom(*source);
  }
}

void PublicKey::MergeFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PublicKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.key().size() > 0) {

    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.encodingtype() != 0) {
    set_encodingtype(from.encodingtype());
  }
  if (from.fingerprint().size() > 0) {

    fingerprint_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fingerprint_);
  }
  if (from.has_ref()) {
    mutable_ref()->::MessageReference::MergeFrom(from.ref());
  }
}

void PublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PublicKey::CopyFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {

  return true;
}

void PublicKey::Swap(PublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PublicKey::InternalSwap(PublicKey* other) {
  key_.Swap(&other->key_);
  std::swap(type_, other->type_);
  std::swap(encodingtype_, other->encodingtype_);
  fingerprint_.Swap(&other->fingerprint_);
  std::swap(ref_, other->ref_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PublicKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PublicKey_descriptor_;
  metadata.reflection = PublicKey_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PublicKey

// optional bytes key = 2;
void PublicKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PublicKey::key() const {
  // @@protoc_insertion_point(field_get:PublicKey.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.key)
}
 void PublicKey::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.key)
}
 void PublicKey::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.key)
}
 ::std::string* PublicKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PublicKey::release_key() {
  // @@protoc_insertion_point(field_release:PublicKey.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.key)
}

// optional .ECCKeyType type = 3;
void PublicKey::clear_type() {
  type_ = 0;
}
 ::ECCKeyType PublicKey::type() const {
  // @@protoc_insertion_point(field_get:PublicKey.type)
  return static_cast< ::ECCKeyType >(type_);
}
 void PublicKey::set_type(::ECCKeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PublicKey.type)
}

// optional .KeyEncodingType encodingType = 4;
void PublicKey::clear_encodingtype() {
  encodingtype_ = 0;
}
 ::KeyEncodingType PublicKey::encodingtype() const {
  // @@protoc_insertion_point(field_get:PublicKey.encodingType)
  return static_cast< ::KeyEncodingType >(encodingtype_);
}
 void PublicKey::set_encodingtype(::KeyEncodingType value) {
  
  encodingtype_ = value;
  // @@protoc_insertion_point(field_set:PublicKey.encodingType)
}

// optional bytes fingerprint = 5;
void PublicKey::clear_fingerprint() {
  fingerprint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PublicKey::fingerprint() const {
  // @@protoc_insertion_point(field_get:PublicKey.fingerprint)
  return fingerprint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_fingerprint(const ::std::string& value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublicKey.fingerprint)
}
 void PublicKey::set_fingerprint(const char* value) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublicKey.fingerprint)
}
 void PublicKey::set_fingerprint(const void* value, size_t size) {
  
  fingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublicKey.fingerprint)
}
 ::std::string* PublicKey::mutable_fingerprint() {
  
  // @@protoc_insertion_point(field_mutable:PublicKey.fingerprint)
  return fingerprint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PublicKey::release_fingerprint() {
  // @@protoc_insertion_point(field_release:PublicKey.fingerprint)
  
  return fingerprint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PublicKey::set_allocated_fingerprint(::std::string* fingerprint) {
  if (fingerprint != NULL) {
    
  } else {
    
  }
  fingerprint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fingerprint);
  // @@protoc_insertion_point(field_set_allocated:PublicKey.fingerprint)
}

// optional .MessageReference ref = 6;
bool PublicKey::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
void PublicKey::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
const ::MessageReference& PublicKey::ref() const {
  // @@protoc_insertion_point(field_get:PublicKey.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
::MessageReference* PublicKey::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:PublicKey.ref)
  return ref_;
}
::MessageReference* PublicKey::release_ref() {
  // @@protoc_insertion_point(field_release:PublicKey.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
void PublicKey::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PublicKey.ref)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SymmetriclyEncryptedMessage::kMessageTypeFieldNumber;
const int SymmetriclyEncryptedMessage::kEncryptionTypeFieldNumber;
const int SymmetriclyEncryptedMessage::kMsgFieldNumber;
const int SymmetriclyEncryptedMessage::kIvFieldNumber;
const int SymmetriclyEncryptedMessage::kSaltFieldNumber;
const int SymmetriclyEncryptedMessage::kRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SymmetriclyEncryptedMessage::SymmetriclyEncryptedMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SymmetriclyEncryptedMessage)
}

void SymmetriclyEncryptedMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  ref_ = const_cast< ::MessageReference*>(&::MessageReference::default_instance());
}

SymmetriclyEncryptedMessage::SymmetriclyEncryptedMessage(const SymmetriclyEncryptedMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SymmetriclyEncryptedMessage)
}

void SymmetriclyEncryptedMessage::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_type_ = 0;
  encryption_type_ = 0;
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  salt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ref_ = NULL;
}

SymmetriclyEncryptedMessage::~SymmetriclyEncryptedMessage() {
  // @@protoc_insertion_point(destructor:SymmetriclyEncryptedMessage)
  SharedDtor();
}

void SymmetriclyEncryptedMessage::SharedDtor() {
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  salt_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete ref_;
  }
}

void SymmetriclyEncryptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SymmetriclyEncryptedMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SymmetriclyEncryptedMessage_descriptor_;
}

const SymmetriclyEncryptedMessage& SymmetriclyEncryptedMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

SymmetriclyEncryptedMessage* SymmetriclyEncryptedMessage::default_instance_ = NULL;

SymmetriclyEncryptedMessage* SymmetriclyEncryptedMessage::New(::google::protobuf::Arena* arena) const {
  SymmetriclyEncryptedMessage* n = new SymmetriclyEncryptedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SymmetriclyEncryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SymmetriclyEncryptedMessage)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SymmetriclyEncryptedMessage, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SymmetriclyEncryptedMessage*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(message_type_, encryption_type_);
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;

#undef ZR_HELPER_
#undef ZR_

}

bool SymmetriclyEncryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SymmetriclyEncryptedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MessageType message_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_message_type(static_cast< ::MessageType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_encryption_type;
        break;
      }

      // optional .EncryptionType encryption_type = 2;
      case 2: {
        if (tag == 16) {
         parse_encryption_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encryption_type(static_cast< ::EncryptionType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_msg;
        break;
      }

      // optional bytes msg = 3;
      case 3: {
        if (tag == 26) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_iv;
        break;
      }

      // optional bytes iv = 4;
      case 4: {
        if (tag == 34) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_salt;
        break;
      }

      // optional bytes salt = 5;
      case 5: {
        if (tag == 42) {
         parse_salt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_salt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ref;
        break;
      }

      // optional .MessageReference ref = 6;
      case 6: {
        if (tag == 50) {
         parse_ref:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SymmetriclyEncryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SymmetriclyEncryptedMessage)
  return false;
#undef DO_
}

void SymmetriclyEncryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SymmetriclyEncryptedMessage)
  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->message_type(), output);
  }

  // optional .EncryptionType encryption_type = 2;
  if (this->encryption_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->encryption_type(), output);
  }

  // optional bytes msg = 3;
  if (this->msg().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->msg(), output);
  }

  // optional bytes iv = 4;
  if (this->iv().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->iv(), output);
  }

  // optional bytes salt = 5;
  if (this->salt().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->salt(), output);
  }

  // optional .MessageReference ref = 6;
  if (this->has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->ref_, output);
  }

  // @@protoc_insertion_point(serialize_end:SymmetriclyEncryptedMessage)
}

::google::protobuf::uint8* SymmetriclyEncryptedMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SymmetriclyEncryptedMessage)
  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->message_type(), target);
  }

  // optional .EncryptionType encryption_type = 2;
  if (this->encryption_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->encryption_type(), target);
  }

  // optional bytes msg = 3;
  if (this->msg().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->msg(), target);
  }

  // optional bytes iv = 4;
  if (this->iv().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->iv(), target);
  }

  // optional bytes salt = 5;
  if (this->salt().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->salt(), target);
  }

  // optional .MessageReference ref = 6;
  if (this->has_ref()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->ref_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:SymmetriclyEncryptedMessage)
  return target;
}

int SymmetriclyEncryptedMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:SymmetriclyEncryptedMessage)
  int total_size = 0;

  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
  }

  // optional .EncryptionType encryption_type = 2;
  if (this->encryption_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encryption_type());
  }

  // optional bytes msg = 3;
  if (this->msg().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->msg());
  }

  // optional bytes iv = 4;
  if (this->iv().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->iv());
  }

  // optional bytes salt = 5;
  if (this->salt().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->salt());
  }

  // optional .MessageReference ref = 6;
  if (this->has_ref()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->ref_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SymmetriclyEncryptedMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SymmetriclyEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SymmetriclyEncryptedMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SymmetriclyEncryptedMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SymmetriclyEncryptedMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SymmetriclyEncryptedMessage)
    MergeFrom(*source);
  }
}

void SymmetriclyEncryptedMessage::MergeFrom(const SymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SymmetriclyEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.message_type() != 0) {
    set_message_type(from.message_type());
  }
  if (from.encryption_type() != 0) {
    set_encryption_type(from.encryption_type());
  }
  if (from.msg().size() > 0) {

    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
  if (from.iv().size() > 0) {

    iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
  }
  if (from.salt().size() > 0) {

    salt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.salt_);
  }
  if (from.has_ref()) {
    mutable_ref()->::MessageReference::MergeFrom(from.ref());
  }
}

void SymmetriclyEncryptedMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SymmetriclyEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SymmetriclyEncryptedMessage::CopyFrom(const SymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SymmetriclyEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymmetriclyEncryptedMessage::IsInitialized() const {

  return true;
}

void SymmetriclyEncryptedMessage::Swap(SymmetriclyEncryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SymmetriclyEncryptedMessage::InternalSwap(SymmetriclyEncryptedMessage* other) {
  std::swap(message_type_, other->message_type_);
  std::swap(encryption_type_, other->encryption_type_);
  msg_.Swap(&other->msg_);
  iv_.Swap(&other->iv_);
  salt_.Swap(&other->salt_);
  std::swap(ref_, other->ref_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SymmetriclyEncryptedMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SymmetriclyEncryptedMessage_descriptor_;
  metadata.reflection = SymmetriclyEncryptedMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
void SymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
 ::MessageType SymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
 void SymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.message_type)
}

// optional .EncryptionType encryption_type = 2;
void SymmetriclyEncryptedMessage::clear_encryption_type() {
  encryption_type_ = 0;
}
 ::EncryptionType SymmetriclyEncryptedMessage::encryption_type() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.encryption_type)
  return static_cast< ::EncryptionType >(encryption_type_);
}
 void SymmetriclyEncryptedMessage::set_encryption_type(::EncryptionType value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.encryption_type)
}

// optional bytes msg = 3;
void SymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.msg)
}
 void SymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.msg)
}
 void SymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.msg)
}
 ::std::string* SymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.msg)
}

// optional bytes iv = 4;
void SymmetriclyEncryptedMessage::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SymmetriclyEncryptedMessage::iv() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.iv)
}
 void SymmetriclyEncryptedMessage::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.iv)
}
 void SymmetriclyEncryptedMessage::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.iv)
}
 ::std::string* SymmetriclyEncryptedMessage::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymmetriclyEncryptedMessage::release_iv() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.iv)
}

// optional bytes salt = 5;
void SymmetriclyEncryptedMessage::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& SymmetriclyEncryptedMessage::salt() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.salt)
  return salt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SymmetriclyEncryptedMessage.salt)
}
 void SymmetriclyEncryptedMessage::set_salt(const char* value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SymmetriclyEncryptedMessage.salt)
}
 void SymmetriclyEncryptedMessage::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SymmetriclyEncryptedMessage.salt)
}
 ::std::string* SymmetriclyEncryptedMessage::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymmetriclyEncryptedMessage::release_salt() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymmetriclyEncryptedMessage::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.salt)
}

// optional .MessageReference ref = 6;
bool SymmetriclyEncryptedMessage::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
void SymmetriclyEncryptedMessage::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
const ::MessageReference& SymmetriclyEncryptedMessage::ref() const {
  // @@protoc_insertion_point(field_get:SymmetriclyEncryptedMessage.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
::MessageReference* SymmetriclyEncryptedMessage::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:SymmetriclyEncryptedMessage.ref)
  return ref_;
}
::MessageReference* SymmetriclyEncryptedMessage::release_ref() {
  // @@protoc_insertion_point(field_release:SymmetriclyEncryptedMessage.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
void SymmetriclyEncryptedMessage::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SymmetriclyEncryptedMessage.ref)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AsymmetriclyEncryptedMessage::kMessageTypeFieldNumber;
const int AsymmetriclyEncryptedMessage::kDestCnFieldNumber;
const int AsymmetriclyEncryptedMessage::kMsgFieldNumber;
const int AsymmetriclyEncryptedMessage::kRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AsymmetriclyEncryptedMessage::AsymmetriclyEncryptedMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AsymmetriclyEncryptedMessage)
}

void AsymmetriclyEncryptedMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  ref_ = const_cast< ::MessageReference*>(&::MessageReference::default_instance());
}

AsymmetriclyEncryptedMessage::AsymmetriclyEncryptedMessage(const AsymmetriclyEncryptedMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AsymmetriclyEncryptedMessage)
}

void AsymmetriclyEncryptedMessage::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_type_ = 0;
  dest_cn_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ref_ = NULL;
}

AsymmetriclyEncryptedMessage::~AsymmetriclyEncryptedMessage() {
  // @@protoc_insertion_point(destructor:AsymmetriclyEncryptedMessage)
  SharedDtor();
}

void AsymmetriclyEncryptedMessage::SharedDtor() {
  dest_cn_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete ref_;
  }
}

void AsymmetriclyEncryptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AsymmetriclyEncryptedMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AsymmetriclyEncryptedMessage_descriptor_;
}

const AsymmetriclyEncryptedMessage& AsymmetriclyEncryptedMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

AsymmetriclyEncryptedMessage* AsymmetriclyEncryptedMessage::default_instance_ = NULL;

AsymmetriclyEncryptedMessage* AsymmetriclyEncryptedMessage::New(::google::protobuf::Arena* arena) const {
  AsymmetriclyEncryptedMessage* n = new AsymmetriclyEncryptedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AsymmetriclyEncryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AsymmetriclyEncryptedMessage)
  message_type_ = 0;
  dest_cn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}

bool AsymmetriclyEncryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AsymmetriclyEncryptedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MessageType message_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_message_type(static_cast< ::MessageType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_dest_cn;
        break;
      }

      // optional string dest_cn = 2;
      case 2: {
        if (tag == 18) {
         parse_dest_cn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dest_cn()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->dest_cn().data(), this->dest_cn().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "AsymmetriclyEncryptedMessage.dest_cn"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_msg;
        break;
      }

      // optional bytes msg = 4;
      case 4: {
        if (tag == 34) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ref;
        break;
      }

      // optional .MessageReference ref = 5;
      case 5: {
        if (tag == 42) {
         parse_ref:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AsymmetriclyEncryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AsymmetriclyEncryptedMessage)
  return false;
#undef DO_
}

void AsymmetriclyEncryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AsymmetriclyEncryptedMessage)
  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->message_type(), output);
  }

  // optional string dest_cn = 2;
  if (this->dest_cn().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->dest_cn().data(), this->dest_cn().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "AsymmetriclyEncryptedMessage.dest_cn");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->dest_cn(), output);
  }

  // optional bytes msg = 4;
  if (this->msg().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->msg(), output);
  }

  // optional .MessageReference ref = 5;
  if (this->has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->ref_, output);
  }

  // @@protoc_insertion_point(serialize_end:AsymmetriclyEncryptedMessage)
}

::google::protobuf::uint8* AsymmetriclyEncryptedMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AsymmetriclyEncryptedMessage)
  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->message_type(), target);
  }

  // optional string dest_cn = 2;
  if (this->dest_cn().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->dest_cn().data(), this->dest_cn().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "AsymmetriclyEncryptedMessage.dest_cn");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->dest_cn(), target);
  }

  // optional bytes msg = 4;
  if (this->msg().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->msg(), target);
  }

  // optional .MessageReference ref = 5;
  if (this->has_ref()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->ref_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:AsymmetriclyEncryptedMessage)
  return target;
}

int AsymmetriclyEncryptedMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:AsymmetriclyEncryptedMessage)
  int total_size = 0;

  // optional .MessageType message_type = 1;
  if (this->message_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
  }

  // optional string dest_cn = 2;
  if (this->dest_cn().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->dest_cn());
  }

  // optional bytes msg = 4;
  if (this->msg().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->msg());
  }

  // optional .MessageReference ref = 5;
  if (this->has_ref()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->ref_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AsymmetriclyEncryptedMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AsymmetriclyEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const AsymmetriclyEncryptedMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AsymmetriclyEncryptedMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AsymmetriclyEncryptedMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AsymmetriclyEncryptedMessage)
    MergeFrom(*source);
  }
}

void AsymmetriclyEncryptedMessage::MergeFrom(const AsymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AsymmetriclyEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.message_type() != 0) {
    set_message_type(from.message_type());
  }
  if (from.dest_cn().size() > 0) {

    dest_cn_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dest_cn_);
  }
  if (from.msg().size() > 0) {

    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
  if (from.has_ref()) {
    mutable_ref()->::MessageReference::MergeFrom(from.ref());
  }
}

void AsymmetriclyEncryptedMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AsymmetriclyEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AsymmetriclyEncryptedMessage::CopyFrom(const AsymmetriclyEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AsymmetriclyEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymmetriclyEncryptedMessage::IsInitialized() const {

  return true;
}

void AsymmetriclyEncryptedMessage::Swap(AsymmetriclyEncryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AsymmetriclyEncryptedMessage::InternalSwap(AsymmetriclyEncryptedMessage* other) {
  std::swap(message_type_, other->message_type_);
  dest_cn_.Swap(&other->dest_cn_);
  msg_.Swap(&other->msg_);
  std::swap(ref_, other->ref_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AsymmetriclyEncryptedMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AsymmetriclyEncryptedMessage_descriptor_;
  metadata.reflection = AsymmetriclyEncryptedMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AsymmetriclyEncryptedMessage

// optional .MessageType message_type = 1;
void AsymmetriclyEncryptedMessage::clear_message_type() {
  message_type_ = 0;
}
 ::MessageType AsymmetriclyEncryptedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.message_type)
  return static_cast< ::MessageType >(message_type_);
}
 void AsymmetriclyEncryptedMessage::set_message_type(::MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.message_type)
}

// optional string dest_cn = 2;
void AsymmetriclyEncryptedMessage::clear_dest_cn() {
  dest_cn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AsymmetriclyEncryptedMessage::dest_cn() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.dest_cn)
  return dest_cn_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_dest_cn(const ::std::string& value) {
  
  dest_cn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.dest_cn)
}
 void AsymmetriclyEncryptedMessage::set_dest_cn(const char* value) {
  
  dest_cn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.dest_cn)
}
 void AsymmetriclyEncryptedMessage::set_dest_cn(const char* value, size_t size) {
  
  dest_cn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.dest_cn)
}
 ::std::string* AsymmetriclyEncryptedMessage::mutable_dest_cn() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.dest_cn)
  return dest_cn_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AsymmetriclyEncryptedMessage::release_dest_cn() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.dest_cn)
  
  return dest_cn_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_allocated_dest_cn(::std::string* dest_cn) {
  if (dest_cn != NULL) {
    
  } else {
    
  }
  dest_cn_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_cn);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.dest_cn)
}

// optional bytes msg = 4;
void AsymmetriclyEncryptedMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AsymmetriclyEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AsymmetriclyEncryptedMessage.msg)
}
 void AsymmetriclyEncryptedMessage::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AsymmetriclyEncryptedMessage.msg)
}
 void AsymmetriclyEncryptedMessage::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AsymmetriclyEncryptedMessage.msg)
}
 ::std::string* AsymmetriclyEncryptedMessage::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AsymmetriclyEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AsymmetriclyEncryptedMessage::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.msg)
}

// optional .MessageReference ref = 5;
bool AsymmetriclyEncryptedMessage::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
void AsymmetriclyEncryptedMessage::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
const ::MessageReference& AsymmetriclyEncryptedMessage::ref() const {
  // @@protoc_insertion_point(field_get:AsymmetriclyEncryptedMessage.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
::MessageReference* AsymmetriclyEncryptedMessage::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:AsymmetriclyEncryptedMessage.ref)
  return ref_;
}
::MessageReference* AsymmetriclyEncryptedMessage::release_ref() {
  // @@protoc_insertion_point(field_release:AsymmetriclyEncryptedMessage.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
void AsymmetriclyEncryptedMessage::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:AsymmetriclyEncryptedMessage.ref)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HybridEncryptedMessage::kKeyFieldNumber;
const int HybridEncryptedMessage::kMsgFieldNumber;
const int HybridEncryptedMessage::kRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HybridEncryptedMessage::HybridEncryptedMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:HybridEncryptedMessage)
}

void HybridEncryptedMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  key_ = const_cast< ::AsymmetriclyEncryptedMessage*>(&::AsymmetriclyEncryptedMessage::default_instance());
  msg_ = const_cast< ::SymmetriclyEncryptedMessage*>(&::SymmetriclyEncryptedMessage::default_instance());
  ref_ = const_cast< ::MessageReference*>(&::MessageReference::default_instance());
}

HybridEncryptedMessage::HybridEncryptedMessage(const HybridEncryptedMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HybridEncryptedMessage)
}

void HybridEncryptedMessage::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  key_ = NULL;
  msg_ = NULL;
  ref_ = NULL;
}

HybridEncryptedMessage::~HybridEncryptedMessage() {
  // @@protoc_insertion_point(destructor:HybridEncryptedMessage)
  SharedDtor();
}

void HybridEncryptedMessage::SharedDtor() {
  if (this != default_instance_) {
    delete key_;
    delete msg_;
    delete ref_;
  }
}

void HybridEncryptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HybridEncryptedMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HybridEncryptedMessage_descriptor_;
}

const HybridEncryptedMessage& HybridEncryptedMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

HybridEncryptedMessage* HybridEncryptedMessage::default_instance_ = NULL;

HybridEncryptedMessage* HybridEncryptedMessage::New(::google::protobuf::Arena* arena) const {
  HybridEncryptedMessage* n = new HybridEncryptedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HybridEncryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:HybridEncryptedMessage)
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
  if (GetArenaNoVirtual() == NULL && msg_ != NULL) delete msg_;
  msg_ = NULL;
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}

bool HybridEncryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:HybridEncryptedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .AsymmetriclyEncryptedMessage key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg;
        break;
      }

      // optional .SymmetriclyEncryptedMessage msg = 2;
      case 2: {
        if (tag == 18) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ref;
        break;
      }

      // optional .MessageReference ref = 3;
      case 3: {
        if (tag == 26) {
         parse_ref:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HybridEncryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HybridEncryptedMessage)
  return false;
#undef DO_
}

void HybridEncryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HybridEncryptedMessage)
  // optional .AsymmetriclyEncryptedMessage key = 1;
  if (this->has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->key_, output);
  }

  // optional .SymmetriclyEncryptedMessage msg = 2;
  if (this->has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->msg_, output);
  }

  // optional .MessageReference ref = 3;
  if (this->has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->ref_, output);
  }

  // @@protoc_insertion_point(serialize_end:HybridEncryptedMessage)
}

::google::protobuf::uint8* HybridEncryptedMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:HybridEncryptedMessage)
  // optional .AsymmetriclyEncryptedMessage key = 1;
  if (this->has_key()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->key_, false, target);
  }

  // optional .SymmetriclyEncryptedMessage msg = 2;
  if (this->has_msg()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->msg_, false, target);
  }

  // optional .MessageReference ref = 3;
  if (this->has_ref()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->ref_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:HybridEncryptedMessage)
  return target;
}

int HybridEncryptedMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:HybridEncryptedMessage)
  int total_size = 0;

  // optional .AsymmetriclyEncryptedMessage key = 1;
  if (this->has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->key_);
  }

  // optional .SymmetriclyEncryptedMessage msg = 2;
  if (this->has_msg()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->msg_);
  }

  // optional .MessageReference ref = 3;
  if (this->has_ref()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->ref_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HybridEncryptedMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:HybridEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HybridEncryptedMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HybridEncryptedMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:HybridEncryptedMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:HybridEncryptedMessage)
    MergeFrom(*source);
  }
}

void HybridEncryptedMessage::MergeFrom(const HybridEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HybridEncryptedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.has_key()) {
    mutable_key()->::AsymmetriclyEncryptedMessage::MergeFrom(from.key());
  }
  if (from.has_msg()) {
    mutable_msg()->::SymmetriclyEncryptedMessage::MergeFrom(from.msg());
  }
  if (from.has_ref()) {
    mutable_ref()->::MessageReference::MergeFrom(from.ref());
  }
}

void HybridEncryptedMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:HybridEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HybridEncryptedMessage::CopyFrom(const HybridEncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HybridEncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HybridEncryptedMessage::IsInitialized() const {

  return true;
}

void HybridEncryptedMessage::Swap(HybridEncryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HybridEncryptedMessage::InternalSwap(HybridEncryptedMessage* other) {
  std::swap(key_, other->key_);
  std::swap(msg_, other->msg_);
  std::swap(ref_, other->ref_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HybridEncryptedMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HybridEncryptedMessage_descriptor_;
  metadata.reflection = HybridEncryptedMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HybridEncryptedMessage

// optional .AsymmetriclyEncryptedMessage key = 1;
bool HybridEncryptedMessage::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
void HybridEncryptedMessage::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
const ::AsymmetriclyEncryptedMessage& HybridEncryptedMessage::key() const {
  // @@protoc_insertion_point(field_get:HybridEncryptedMessage.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
::AsymmetriclyEncryptedMessage* HybridEncryptedMessage::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::AsymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:HybridEncryptedMessage.key)
  return key_;
}
::AsymmetriclyEncryptedMessage* HybridEncryptedMessage::release_key() {
  // @@protoc_insertion_point(field_release:HybridEncryptedMessage.key)
  
  ::AsymmetriclyEncryptedMessage* temp = key_;
  key_ = NULL;
  return temp;
}
void HybridEncryptedMessage::set_allocated_key(::AsymmetriclyEncryptedMessage* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:HybridEncryptedMessage.key)
}

// optional .SymmetriclyEncryptedMessage msg = 2;
bool HybridEncryptedMessage::has_msg() const {
  return !_is_default_instance_ && msg_ != NULL;
}
void HybridEncryptedMessage::clear_msg() {
  if (GetArenaNoVirtual() == NULL && msg_ != NULL) delete msg_;
  msg_ = NULL;
}
const ::SymmetriclyEncryptedMessage& HybridEncryptedMessage::msg() const {
  // @@protoc_insertion_point(field_get:HybridEncryptedMessage.msg)
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
::SymmetriclyEncryptedMessage* HybridEncryptedMessage::mutable_msg() {
  
  if (msg_ == NULL) {
    msg_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:HybridEncryptedMessage.msg)
  return msg_;
}
::SymmetriclyEncryptedMessage* HybridEncryptedMessage::release_msg() {
  // @@protoc_insertion_point(field_release:HybridEncryptedMessage.msg)
  
  ::SymmetriclyEncryptedMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
void HybridEncryptedMessage::set_allocated_msg(::SymmetriclyEncryptedMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:HybridEncryptedMessage.msg)
}

// optional .MessageReference ref = 3;
bool HybridEncryptedMessage::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
void HybridEncryptedMessage::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
const ::MessageReference& HybridEncryptedMessage::ref() const {
  // @@protoc_insertion_point(field_get:HybridEncryptedMessage.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
::MessageReference* HybridEncryptedMessage::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:HybridEncryptedMessage.ref)
  return ref_;
}
::MessageReference* HybridEncryptedMessage::release_ref() {
  // @@protoc_insertion_point(field_release:HybridEncryptedMessage.ref)
  
  ::MessageReference* temp = ref_;
  ref_ = NULL;
  return temp;
}
void HybridEncryptedMessage::set_allocated_ref(::MessageReference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:HybridEncryptedMessage.ref)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MessageReference::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MessageReference::MessageReference()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MessageReference)
}

void MessageReference::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

MessageReference::MessageReference(const MessageReference& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MessageReference)
}

void MessageReference::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

MessageReference::~MessageReference() {
  // @@protoc_insertion_point(destructor:MessageReference)
  SharedDtor();
}

void MessageReference::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MessageReference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MessageReference::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageReference_descriptor_;
}

const MessageReference& MessageReference::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

MessageReference* MessageReference::default_instance_ = NULL;

MessageReference* MessageReference::New(::google::protobuf::Arena* arena) const {
  MessageReference* n = new MessageReference;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MessageReference::Clear() {
// @@protoc_insertion_point(message_clear_start:MessageReference)
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MessageReference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MessageReference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MessageReference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MessageReference)
  return false;
#undef DO_
}

void MessageReference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MessageReference)
  // optional bytes id = 1;
  if (this->id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->id(), output);
  }

  // @@protoc_insertion_point(serialize_end:MessageReference)
}

::google::protobuf::uint8* MessageReference::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MessageReference)
  // optional bytes id = 1;
  if (this->id().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->id(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:MessageReference)
  return target;
}

int MessageReference::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:MessageReference)
  int total_size = 0;

  // optional bytes id = 1;
  if (this->id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->id());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MessageReference::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MessageReference)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MessageReference* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MessageReference>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MessageReference)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MessageReference)
    MergeFrom(*source);
  }
}

void MessageReference::MergeFrom(const MessageReference& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MessageReference)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.id().size() > 0) {

    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void MessageReference::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MessageReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageReference::CopyFrom(const MessageReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MessageReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageReference::IsInitialized() const {

  return true;
}

void MessageReference::Swap(MessageReference* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MessageReference::InternalSwap(MessageReference* other) {
  id_.Swap(&other->id_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MessageReference::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MessageReference_descriptor_;
  metadata.reflection = MessageReference_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MessageReference

// optional bytes id = 1;
void MessageReference::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& MessageReference::id() const {
  // @@protoc_insertion_point(field_get:MessageReference.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MessageReference::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageReference.id)
}
 void MessageReference::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageReference.id)
}
 void MessageReference::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageReference.id)
}
 ::std::string* MessageReference::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:MessageReference.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MessageReference::release_id() {
  // @@protoc_insertion_point(field_release:MessageReference.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MessageReference::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:MessageReference.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignedMessage::kPostFieldNumber;
const int SignedMessage::kSignedMessageFieldNumber;
const int SignedMessage::kPrivateKeyFieldNumber;
const int SignedMessage::kPublicKeyFieldNumber;
const int SignedMessage::kSymmetriclyEncryptedMessageFieldNumber;
const int SignedMessage::kAsymmetriclyEncryptedMessageFieldNumber;
const int SignedMessage::kHybridEncryptedMessageFieldNumber;
const int SignedMessage::kReferenceFieldNumber;
const int SignedMessage::kMessageSignatureFieldNumber;
const int SignedMessage::kTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignedMessage::SignedMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SignedMessage)
}

void SignedMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  SignedMessage_default_oneof_instance_->post_ = const_cast< ::Post*>(&::Post::default_instance());
  SignedMessage_default_oneof_instance_->signedmessage_ = const_cast< ::Signature*>(&::Signature::default_instance());
  SignedMessage_default_oneof_instance_->privatekey_ = const_cast< ::PrivateKey*>(&::PrivateKey::default_instance());
  SignedMessage_default_oneof_instance_->publickey_ = const_cast< ::PublicKey*>(&::PublicKey::default_instance());
  SignedMessage_default_oneof_instance_->symmetriclyencryptedmessage_ = const_cast< ::SymmetriclyEncryptedMessage*>(&::SymmetriclyEncryptedMessage::default_instance());
  SignedMessage_default_oneof_instance_->asymmetriclyencryptedmessage_ = const_cast< ::AsymmetriclyEncryptedMessage*>(&::AsymmetriclyEncryptedMessage::default_instance());
  SignedMessage_default_oneof_instance_->hybridencryptedmessage_ = const_cast< ::HybridEncryptedMessage*>(&::HybridEncryptedMessage::default_instance());
  SignedMessage_default_oneof_instance_->reference_ = const_cast< ::MessageReference*>(&::MessageReference::default_instance());
  message_signature_ = const_cast< ::Signature*>(&::Signature::default_instance());
}

SignedMessage::SignedMessage(const SignedMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SignedMessage)
}

void SignedMessage::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  message_signature_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_msg();
}

SignedMessage::~SignedMessage() {
  // @@protoc_insertion_point(destructor:SignedMessage)
  SharedDtor();
}

void SignedMessage::SharedDtor() {
  if (has_msg()) {
    clear_msg();
  }
  if (this != default_instance_) {
    delete message_signature_;
  }
}

void SignedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignedMessage_descriptor_;
}

const SignedMessage& SignedMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
  return *default_instance_;
}

SignedMessage* SignedMessage::default_instance_ = NULL;

SignedMessage* SignedMessage::New(::google::protobuf::Arena* arena) const {
  SignedMessage* n = new SignedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SignedMessage::clear_msg() {
// @@protoc_insertion_point(one_of_clear_start:SignedMessage)
  switch(msg_case()) {
    case kPost: {
      delete msg_.post_;
      break;
    }
    case kSignedMessage: {
      delete msg_.signedmessage_;
      break;
    }
    case kPrivateKey: {
      delete msg_.privatekey_;
      break;
    }
    case kPublicKey: {
      delete msg_.publickey_;
      break;
    }
    case kSymmetriclyEncryptedMessage: {
      delete msg_.symmetriclyencryptedmessage_;
      break;
    }
    case kAsymmetriclyEncryptedMessage: {
      delete msg_.asymmetriclyencryptedmessage_;
      break;
    }
    case kHybridEncryptedMessage: {
      delete msg_.hybridencryptedmessage_;
      break;
    }
    case kReference: {
      delete msg_.reference_;
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MSG_NOT_SET;
}


void SignedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SignedMessage)
  if (GetArenaNoVirtual() == NULL && message_signature_ != NULL) delete message_signature_;
  message_signature_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_msg();
}

bool SignedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SignedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Post post = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_post()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signedMessage;
        break;
      }

      // optional .Signature signedMessage = 2;
      case 2: {
        if (tag == 18) {
         parse_signedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signedmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_privateKey;
        break;
      }

      // optional .PrivateKey privateKey = 3;
      case 3: {
        if (tag == 26) {
         parse_privateKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_privatekey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_publicKey;
        break;
      }

      // optional .PublicKey publicKey = 4;
      case 4: {
        if (tag == 34) {
         parse_publicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_publickey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_symmetriclyEncryptedMessage;
        break;
      }

      // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
      case 5: {
        if (tag == 42) {
         parse_symmetriclyEncryptedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_symmetriclyencryptedmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_asymmetriclyEncryptedMessage;
        break;
      }

      // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
      case 6: {
        if (tag == 50) {
         parse_asymmetriclyEncryptedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_asymmetriclyencryptedmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_hybridEncryptedMessage;
        break;
      }

      // optional .HybridEncryptedMessage hybridEncryptedMessage = 7;
      case 7: {
        if (tag == 58) {
         parse_hybridEncryptedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hybridencryptedmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_message_signature;
        break;
      }

      // optional .Signature message_signature = 8;
      case 8: {
        if (tag == 66) {
         parse_message_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_timestamp;
        break;
      }

      // optional fixed64 timestamp = 9;
      case 9: {
        if (tag == 73) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &timestamp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_reference;
        break;
      }

      // optional .MessageReference reference = 10;
      case 10: {
        if (tag == 82) {
         parse_reference:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reference()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SignedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SignedMessage)
  return false;
#undef DO_
}

void SignedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SignedMessage)
  // optional .Post post = 1;
  if (has_post()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *msg_.post_, output);
  }

  // optional .Signature signedMessage = 2;
  if (has_signedmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *msg_.signedmessage_, output);
  }

  // optional .PrivateKey privateKey = 3;
  if (has_privatekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *msg_.privatekey_, output);
  }

  // optional .PublicKey publicKey = 4;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *msg_.publickey_, output);
  }

  // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
  if (has_symmetriclyencryptedmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *msg_.symmetriclyencryptedmessage_, output);
  }

  // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
  if (has_asymmetriclyencryptedmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *msg_.asymmetriclyencryptedmessage_, output);
  }

  // optional .HybridEncryptedMessage hybridEncryptedMessage = 7;
  if (has_hybridencryptedmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *msg_.hybridencryptedmessage_, output);
  }

  // optional .Signature message_signature = 8;
  if (this->has_message_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->message_signature_, output);
  }

  // optional fixed64 timestamp = 9;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(9, this->timestamp(), output);
  }

  // optional .MessageReference reference = 10;
  if (has_reference()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *msg_.reference_, output);
  }

  // @@protoc_insertion_point(serialize_end:SignedMessage)
}

::google::protobuf::uint8* SignedMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SignedMessage)
  // optional .Post post = 1;
  if (has_post()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *msg_.post_, false, target);
  }

  // optional .Signature signedMessage = 2;
  if (has_signedmessage()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *msg_.signedmessage_, false, target);
  }

  // optional .PrivateKey privateKey = 3;
  if (has_privatekey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *msg_.privatekey_, false, target);
  }

  // optional .PublicKey publicKey = 4;
  if (has_publickey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *msg_.publickey_, false, target);
  }

  // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
  if (has_symmetriclyencryptedmessage()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *msg_.symmetriclyencryptedmessage_, false, target);
  }

  // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
  if (has_asymmetriclyencryptedmessage()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *msg_.asymmetriclyencryptedmessage_, false, target);
  }

  // optional .HybridEncryptedMessage hybridEncryptedMessage = 7;
  if (has_hybridencryptedmessage()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *msg_.hybridencryptedmessage_, false, target);
  }

  // optional .Signature message_signature = 8;
  if (this->has_message_signature()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->message_signature_, false, target);
  }

  // optional fixed64 timestamp = 9;
  if (this->timestamp() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(9, this->timestamp(), target);
  }

  // optional .MessageReference reference = 10;
  if (has_reference()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *msg_.reference_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:SignedMessage)
  return target;
}

int SignedMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:SignedMessage)
  int total_size = 0;

  // optional .Signature message_signature = 8;
  if (this->has_message_signature()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->message_signature_);
  }

  // optional fixed64 timestamp = 9;
  if (this->timestamp() != 0) {
    total_size += 1 + 8;
  }

  switch (msg_case()) {
    // optional .Post post = 1;
    case kPost: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.post_);
      break;
    }
    // optional .Signature signedMessage = 2;
    case kSignedMessage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.signedmessage_);
      break;
    }
    // optional .PrivateKey privateKey = 3;
    case kPrivateKey: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.privatekey_);
      break;
    }
    // optional .PublicKey publicKey = 4;
    case kPublicKey: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.publickey_);
      break;
    }
    // optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
    case kSymmetriclyEncryptedMessage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.symmetriclyencryptedmessage_);
      break;
    }
    // optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
    case kAsymmetriclyEncryptedMessage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.asymmetriclyencryptedmessage_);
      break;
    }
    // optional .HybridEncryptedMessage hybridEncryptedMessage = 7;
    case kHybridEncryptedMessage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.hybridencryptedmessage_);
      break;
    }
    // optional .MessageReference reference = 10;
    case kReference: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.reference_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SignedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SignedMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SignedMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SignedMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SignedMessage)
    MergeFrom(*source);
  }
}

void SignedMessage::MergeFrom(const SignedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SignedMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.msg_case()) {
    case kPost: {
      mutable_post()->::Post::MergeFrom(from.post());
      break;
    }
    case kSignedMessage: {
      mutable_signedmessage()->::Signature::MergeFrom(from.signedmessage());
      break;
    }
    case kPrivateKey: {
      mutable_privatekey()->::PrivateKey::MergeFrom(from.privatekey());
      break;
    }
    case kPublicKey: {
      mutable_publickey()->::PublicKey::MergeFrom(from.publickey());
      break;
    }
    case kSymmetriclyEncryptedMessage: {
      mutable_symmetriclyencryptedmessage()->::SymmetriclyEncryptedMessage::MergeFrom(from.symmetriclyencryptedmessage());
      break;
    }
    case kAsymmetriclyEncryptedMessage: {
      mutable_asymmetriclyencryptedmessage()->::AsymmetriclyEncryptedMessage::MergeFrom(from.asymmetriclyencryptedmessage());
      break;
    }
    case kHybridEncryptedMessage: {
      mutable_hybridencryptedmessage()->::HybridEncryptedMessage::MergeFrom(from.hybridencryptedmessage());
      break;
    }
    case kReference: {
      mutable_reference()->::MessageReference::MergeFrom(from.reference());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  if (from.has_message_signature()) {
    mutable_message_signature()->::Signature::MergeFrom(from.message_signature());
  }
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
}

void SignedMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SignedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedMessage::CopyFrom(const SignedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SignedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedMessage::IsInitialized() const {

  return true;
}

void SignedMessage::Swap(SignedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignedMessage::InternalSwap(SignedMessage* other) {
  std::swap(message_signature_, other->message_signature_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(msg_, other->msg_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SignedMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignedMessage_descriptor_;
  metadata.reflection = SignedMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SignedMessage

// optional .Post post = 1;
bool SignedMessage::has_post() const {
  return msg_case() == kPost;
}
void SignedMessage::set_has_post() {
  _oneof_case_[0] = kPost;
}
void SignedMessage::clear_post() {
  if (has_post()) {
    delete msg_.post_;
    clear_has_msg();
  }
}
 const ::Post& SignedMessage::post() const {
  // @@protoc_insertion_point(field_get:SignedMessage.post)
  return has_post()
      ? *msg_.post_
      : ::Post::default_instance();
}
::Post* SignedMessage::mutable_post() {
  if (!has_post()) {
    clear_msg();
    set_has_post();
    msg_.post_ = new ::Post;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.post)
  return msg_.post_;
}
::Post* SignedMessage::release_post() {
  // @@protoc_insertion_point(field_release:SignedMessage.post)
  if (has_post()) {
    clear_has_msg();
    ::Post* temp = msg_.post_;
    msg_.post_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_post(::Post* post) {
  clear_msg();
  if (post) {
    set_has_post();
    msg_.post_ = post;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.post)
}

// optional .Signature signedMessage = 2;
bool SignedMessage::has_signedmessage() const {
  return msg_case() == kSignedMessage;
}
void SignedMessage::set_has_signedmessage() {
  _oneof_case_[0] = kSignedMessage;
}
void SignedMessage::clear_signedmessage() {
  if (has_signedmessage()) {
    delete msg_.signedmessage_;
    clear_has_msg();
  }
}
 const ::Signature& SignedMessage::signedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.signedMessage)
  return has_signedmessage()
      ? *msg_.signedmessage_
      : ::Signature::default_instance();
}
::Signature* SignedMessage::mutable_signedmessage() {
  if (!has_signedmessage()) {
    clear_msg();
    set_has_signedmessage();
    msg_.signedmessage_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.signedMessage)
  return msg_.signedmessage_;
}
::Signature* SignedMessage::release_signedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.signedMessage)
  if (has_signedmessage()) {
    clear_has_msg();
    ::Signature* temp = msg_.signedmessage_;
    msg_.signedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_signedmessage(::Signature* signedmessage) {
  clear_msg();
  if (signedmessage) {
    set_has_signedmessage();
    msg_.signedmessage_ = signedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.signedMessage)
}

// optional .PrivateKey privateKey = 3;
bool SignedMessage::has_privatekey() const {
  return msg_case() == kPrivateKey;
}
void SignedMessage::set_has_privatekey() {
  _oneof_case_[0] = kPrivateKey;
}
void SignedMessage::clear_privatekey() {
  if (has_privatekey()) {
    delete msg_.privatekey_;
    clear_has_msg();
  }
}
 const ::PrivateKey& SignedMessage::privatekey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.privateKey)
  return has_privatekey()
      ? *msg_.privatekey_
      : ::PrivateKey::default_instance();
}
::PrivateKey* SignedMessage::mutable_privatekey() {
  if (!has_privatekey()) {
    clear_msg();
    set_has_privatekey();
    msg_.privatekey_ = new ::PrivateKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.privateKey)
  return msg_.privatekey_;
}
::PrivateKey* SignedMessage::release_privatekey() {
  // @@protoc_insertion_point(field_release:SignedMessage.privateKey)
  if (has_privatekey()) {
    clear_has_msg();
    ::PrivateKey* temp = msg_.privatekey_;
    msg_.privatekey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_privatekey(::PrivateKey* privatekey) {
  clear_msg();
  if (privatekey) {
    set_has_privatekey();
    msg_.privatekey_ = privatekey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.privateKey)
}

// optional .PublicKey publicKey = 4;
bool SignedMessage::has_publickey() const {
  return msg_case() == kPublicKey;
}
void SignedMessage::set_has_publickey() {
  _oneof_case_[0] = kPublicKey;
}
void SignedMessage::clear_publickey() {
  if (has_publickey()) {
    delete msg_.publickey_;
    clear_has_msg();
  }
}
 const ::PublicKey& SignedMessage::publickey() const {
  // @@protoc_insertion_point(field_get:SignedMessage.publicKey)
  return has_publickey()
      ? *msg_.publickey_
      : ::PublicKey::default_instance();
}
::PublicKey* SignedMessage::mutable_publickey() {
  if (!has_publickey()) {
    clear_msg();
    set_has_publickey();
    msg_.publickey_ = new ::PublicKey;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.publicKey)
  return msg_.publickey_;
}
::PublicKey* SignedMessage::release_publickey() {
  // @@protoc_insertion_point(field_release:SignedMessage.publicKey)
  if (has_publickey()) {
    clear_has_msg();
    ::PublicKey* temp = msg_.publickey_;
    msg_.publickey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_publickey(::PublicKey* publickey) {
  clear_msg();
  if (publickey) {
    set_has_publickey();
    msg_.publickey_ = publickey;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.publicKey)
}

// optional .SymmetriclyEncryptedMessage symmetriclyEncryptedMessage = 5;
bool SignedMessage::has_symmetriclyencryptedmessage() const {
  return msg_case() == kSymmetriclyEncryptedMessage;
}
void SignedMessage::set_has_symmetriclyencryptedmessage() {
  _oneof_case_[0] = kSymmetriclyEncryptedMessage;
}
void SignedMessage::clear_symmetriclyencryptedmessage() {
  if (has_symmetriclyencryptedmessage()) {
    delete msg_.symmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
 const ::SymmetriclyEncryptedMessage& SignedMessage::symmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.symmetriclyEncryptedMessage)
  return has_symmetriclyencryptedmessage()
      ? *msg_.symmetriclyencryptedmessage_
      : ::SymmetriclyEncryptedMessage::default_instance();
}
::SymmetriclyEncryptedMessage* SignedMessage::mutable_symmetriclyencryptedmessage() {
  if (!has_symmetriclyencryptedmessage()) {
    clear_msg();
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = new ::SymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.symmetriclyEncryptedMessage)
  return msg_.symmetriclyencryptedmessage_;
}
::SymmetriclyEncryptedMessage* SignedMessage::release_symmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.symmetriclyEncryptedMessage)
  if (has_symmetriclyencryptedmessage()) {
    clear_has_msg();
    ::SymmetriclyEncryptedMessage* temp = msg_.symmetriclyencryptedmessage_;
    msg_.symmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_symmetriclyencryptedmessage(::SymmetriclyEncryptedMessage* symmetriclyencryptedmessage) {
  clear_msg();
  if (symmetriclyencryptedmessage) {
    set_has_symmetriclyencryptedmessage();
    msg_.symmetriclyencryptedmessage_ = symmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.symmetriclyEncryptedMessage)
}

// optional .AsymmetriclyEncryptedMessage asymmetriclyEncryptedMessage = 6;
bool SignedMessage::has_asymmetriclyencryptedmessage() const {
  return msg_case() == kAsymmetriclyEncryptedMessage;
}
void SignedMessage::set_has_asymmetriclyencryptedmessage() {
  _oneof_case_[0] = kAsymmetriclyEncryptedMessage;
}
void SignedMessage::clear_asymmetriclyencryptedmessage() {
  if (has_asymmetriclyencryptedmessage()) {
    delete msg_.asymmetriclyencryptedmessage_;
    clear_has_msg();
  }
}
 const ::AsymmetriclyEncryptedMessage& SignedMessage::asymmetriclyencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.asymmetriclyEncryptedMessage)
  return has_asymmetriclyencryptedmessage()
      ? *msg_.asymmetriclyencryptedmessage_
      : ::AsymmetriclyEncryptedMessage::default_instance();
}
::AsymmetriclyEncryptedMessage* SignedMessage::mutable_asymmetriclyencryptedmessage() {
  if (!has_asymmetriclyencryptedmessage()) {
    clear_msg();
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = new ::AsymmetriclyEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.asymmetriclyEncryptedMessage)
  return msg_.asymmetriclyencryptedmessage_;
}
::AsymmetriclyEncryptedMessage* SignedMessage::release_asymmetriclyencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.asymmetriclyEncryptedMessage)
  if (has_asymmetriclyencryptedmessage()) {
    clear_has_msg();
    ::AsymmetriclyEncryptedMessage* temp = msg_.asymmetriclyencryptedmessage_;
    msg_.asymmetriclyencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_asymmetriclyencryptedmessage(::AsymmetriclyEncryptedMessage* asymmetriclyencryptedmessage) {
  clear_msg();
  if (asymmetriclyencryptedmessage) {
    set_has_asymmetriclyencryptedmessage();
    msg_.asymmetriclyencryptedmessage_ = asymmetriclyencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.asymmetriclyEncryptedMessage)
}

// optional .HybridEncryptedMessage hybridEncryptedMessage = 7;
bool SignedMessage::has_hybridencryptedmessage() const {
  return msg_case() == kHybridEncryptedMessage;
}
void SignedMessage::set_has_hybridencryptedmessage() {
  _oneof_case_[0] = kHybridEncryptedMessage;
}
void SignedMessage::clear_hybridencryptedmessage() {
  if (has_hybridencryptedmessage()) {
    delete msg_.hybridencryptedmessage_;
    clear_has_msg();
  }
}
 const ::HybridEncryptedMessage& SignedMessage::hybridencryptedmessage() const {
  // @@protoc_insertion_point(field_get:SignedMessage.hybridEncryptedMessage)
  return has_hybridencryptedmessage()
      ? *msg_.hybridencryptedmessage_
      : ::HybridEncryptedMessage::default_instance();
}
::HybridEncryptedMessage* SignedMessage::mutable_hybridencryptedmessage() {
  if (!has_hybridencryptedmessage()) {
    clear_msg();
    set_has_hybridencryptedmessage();
    msg_.hybridencryptedmessage_ = new ::HybridEncryptedMessage;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.hybridEncryptedMessage)
  return msg_.hybridencryptedmessage_;
}
::HybridEncryptedMessage* SignedMessage::release_hybridencryptedmessage() {
  // @@protoc_insertion_point(field_release:SignedMessage.hybridEncryptedMessage)
  if (has_hybridencryptedmessage()) {
    clear_has_msg();
    ::HybridEncryptedMessage* temp = msg_.hybridencryptedmessage_;
    msg_.hybridencryptedmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_hybridencryptedmessage(::HybridEncryptedMessage* hybridencryptedmessage) {
  clear_msg();
  if (hybridencryptedmessage) {
    set_has_hybridencryptedmessage();
    msg_.hybridencryptedmessage_ = hybridencryptedmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.hybridEncryptedMessage)
}

// optional .MessageReference reference = 10;
bool SignedMessage::has_reference() const {
  return msg_case() == kReference;
}
void SignedMessage::set_has_reference() {
  _oneof_case_[0] = kReference;
}
void SignedMessage::clear_reference() {
  if (has_reference()) {
    delete msg_.reference_;
    clear_has_msg();
  }
}
 const ::MessageReference& SignedMessage::reference() const {
  // @@protoc_insertion_point(field_get:SignedMessage.reference)
  return has_reference()
      ? *msg_.reference_
      : ::MessageReference::default_instance();
}
::MessageReference* SignedMessage::mutable_reference() {
  if (!has_reference()) {
    clear_msg();
    set_has_reference();
    msg_.reference_ = new ::MessageReference;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.reference)
  return msg_.reference_;
}
::MessageReference* SignedMessage::release_reference() {
  // @@protoc_insertion_point(field_release:SignedMessage.reference)
  if (has_reference()) {
    clear_has_msg();
    ::MessageReference* temp = msg_.reference_;
    msg_.reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SignedMessage::set_allocated_reference(::MessageReference* reference) {
  clear_msg();
  if (reference) {
    set_has_reference();
    msg_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.reference)
}

// optional .Signature message_signature = 8;
bool SignedMessage::has_message_signature() const {
  return !_is_default_instance_ && message_signature_ != NULL;
}
void SignedMessage::clear_message_signature() {
  if (GetArenaNoVirtual() == NULL && message_signature_ != NULL) delete message_signature_;
  message_signature_ = NULL;
}
const ::Signature& SignedMessage::message_signature() const {
  // @@protoc_insertion_point(field_get:SignedMessage.message_signature)
  return message_signature_ != NULL ? *message_signature_ : *default_instance_->message_signature_;
}
::Signature* SignedMessage::mutable_message_signature() {
  
  if (message_signature_ == NULL) {
    message_signature_ = new ::Signature;
  }
  // @@protoc_insertion_point(field_mutable:SignedMessage.message_signature)
  return message_signature_;
}
::Signature* SignedMessage::release_message_signature() {
  // @@protoc_insertion_point(field_release:SignedMessage.message_signature)
  
  ::Signature* temp = message_signature_;
  message_signature_ = NULL;
  return temp;
}
void SignedMessage::set_allocated_message_signature(::Signature* message_signature) {
  delete message_signature_;
  message_signature_ = message_signature;
  if (message_signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SignedMessage.message_signature)
}

// optional fixed64 timestamp = 9;
void SignedMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 SignedMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:SignedMessage.timestamp)
  return timestamp_;
}
 void SignedMessage::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SignedMessage.timestamp)
}

bool SignedMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
void SignedMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
SignedMessage::MsgCase SignedMessage::msg_case() const {
  return SignedMessage::MsgCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
